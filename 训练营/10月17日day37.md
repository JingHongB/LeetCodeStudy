## 目录

[509. 斐波那契数](#1)

[70.爬楼梯](#2)

[746. 使用最小花费爬楼梯](#3)



## 509. 斐波那契数<a id=1></a>

### 题目

[509. 斐波那契数 - 力扣（LeetCode）](https://leetcode.cn/problems/fibonacci-number/description/)

**斐波那契数** （通常用 `F(n)` 表示）形成的序列称为 **斐波那契数列** 。该数列由 `0` 和 `1` 开始，后面的每一项数字都是前面两项数字的和。也就是：

```
F(0) = 0，F(1) = 1
F(n) = F(n - 1) + F(n - 2)，其中 n > 1
```

给定 `n` ，请计算 `F(n)` 。

示例 1：

```
输入：n = 2
输出：1
解释：F(2) = F(1) + F(0) = 1 + 0 = 1
```

示例 2：

```
输入：n = 3
输出：2
解释：F(3) = F(2) + F(1) = 1 + 1 = 2
```

示例 3：

```
输入：n = 4
输出：3
解释：F(4) = F(3) + F(2) = 2 + 1 = 3
```

**提示：**

- `0 <= n <= 30`



### 思路

[视频讲解：LeetCode：509.斐波那契数](https://www.bilibili.com/video/BV1f5411K7mo/)

[代码随想录：509.斐波那契数](https://programmercarl.com/0509.斐波那契数.html)

动态规划五部曲：

1. 确定dp数组以及下标含义：使用一维dp数组保存结果，确定`dp[i]`为第i个斐波那契数的值
2. 确定递推公式：`dp[i] = dp[i - 1] + dp[i - 2]`
3. 初始化数组：`dp[0]=0, dp[1]=1`
4. 确定遍历顺序：由递推公式得遍历顺序为从前往后
5. 举例推导：当n为8时，dp数组应该为：0 1 1 2 3 5 8 13



### 题解

```java
class Solution {
    public int fib(int n) {
        if (n <= 1) {
            return n;
        }
        int[] dp = new int[n + 1];
        dp[0] = 0;
        dp[1] = 1;
        for (int i = 2; i <= n; i++) {
            dp[i] = dp[i - 1] + dp[i - 2];
        }
        return dp[n];
    }
}
```



## 70.爬楼梯<a id=2></a>

### 题目

[70. 爬楼梯 - 力扣（LeetCode）](https://leetcode.cn/problems/climbing-stairs/description/)

假设你正在爬楼梯。需要 `n` 阶你才能到达楼顶。

每次你可以爬 `1` 或 `2` 个台阶。你有多少种不同的方法可以爬到楼顶呢？

示例 1：

```
输入：n = 2
输出：2
解释：有两种方法可以爬到楼顶。
1. 1 阶 + 1 阶
2. 2 阶
```

示例 2：

```
输入：n = 3
输出：3
解释：有三种方法可以爬到楼顶。
1. 1 阶 + 1 阶 + 1 阶
2. 1 阶 + 2 阶
3. 2 阶 + 1 阶
```

**提示：**

- `1 <= n <= 45`



### 思路

[视频讲解：LeetCode：70.爬楼梯](https://www.bilibili.com/video/BV17h411h7UH/)

[代码随想录：70.爬楼梯](https://programmercarl.com/0070.爬楼梯.html)

另类的斐波那契数列。

动态规划五部曲：

1. 确定dp数组以及下标含义：使用一维dp数组保存结果，确定`dp[i]`为到第i阶楼梯的方法数
2. 确定递推公式：`dp[i] = dp[i - 1] + dp[i - 2]`，因为`dp[i]`阶楼梯只能从`dp[i-1]`阶和`dp[i-2]`阶楼梯可以一次到达，所以爬到`dp[i]`阶楼梯的方法数应该等于爬到`dp[i-1]`阶和`dp[i-2]`阶楼梯的方法数之和
3. 初始化数组：`dp[1]=1, dp[2]=2`，到第1阶楼梯有1种方法，到第2阶楼梯有2种方法
4. 确定遍历顺序：由递推公式得遍历顺序为从前往后
5. 举例推导：当n为8时，dp数组应该为： 1 2 3 5 8 13 21 34



### 题解

```java
class Solution {
    public int climbStairs(int n) {
        if (n == 1)
            return n;
        int[] dp = new int[n + 1];
        dp[1] = 1;
        dp[2] = 2;
        for (int i = 3; i <= n; i++) {
            dp[i] = dp[i - 1] + dp[i - 2];
        }
        return dp[n];
    }
}
```



## 746. 使用最小花费爬楼梯<a id=3></a>

### 题目

[746. 使用最小花费爬楼梯 - 力扣（LeetCode）](https://leetcode.cn/problems/min-cost-climbing-stairs/description/)

给你一个整数数组 `cost` ，其中 `cost[i]` 是从楼梯第 `i` 个台阶向上爬需要支付的费用。一旦你支付此费用，即可选择向上爬一个或者两个台阶。

你可以选择从下标为 `0` 或下标为 `1` 的台阶开始爬楼梯。

请你计算并返回达到楼梯顶部的最低花费。

**示例 1：**

```
输入：cost = [10,15,20]
输出：15
解释：你将从下标为 1 的台阶开始。
- 支付 15 ，向上爬两个台阶，到达楼梯顶部。
总花费为 15 。
```

**示例 2：**

```
输入：cost = [1,100,1,1,1,100,1,1,100,1]
输出：6
解释：你将从下标为 0 的台阶开始。
- 支付 1 ，向上爬两个台阶，到达下标为 2 的台阶。
- 支付 1 ，向上爬两个台阶，到达下标为 4 的台阶。
- 支付 1 ，向上爬两个台阶，到达下标为 6 的台阶。
- 支付 1 ，向上爬一个台阶，到达下标为 7 的台阶。
- 支付 1 ，向上爬两个台阶，到达下标为 9 的台阶。
- 支付 1 ，向上爬一个台阶，到达楼梯顶部。
总花费为 6 。
```

**提示：**

- `2 <= cost.length <= 1000`
- `0 <= cost[i] <= 999`



### 思路

[视频讲解：LeetCode：746. 使用最小花费爬楼梯](https://www.bilibili.com/video/BV16G411c7yZ/)

[代码随想录：746.使用最小花费爬楼梯](https://programmercarl.com/0746.使用最小花费爬楼梯.html)

动态规划五部曲：

1. 确定dp数组以及下标含义：使用一维dp数组保存结果，确定`dp[i]`为到第i阶楼梯的最小花费
2. 确定递推公式：`dp[i] = dp[i - 1] + dp[i - 2]`，因为`dp[i]`阶楼梯只能从`dp[i-1]`阶和`dp[i-2]`阶楼梯可以一次到达，所以爬到`dp[i]`阶楼梯的最小花费应该为爬到`dp[i-1]`阶和`dp[i-2]`阶楼梯的最小花费的较小值
3. 初始化数组：`dp[0]=0, dp[1]=0`，到第1阶和第2阶楼梯无花费
4. 确定遍历顺序：由递推公式得遍历顺序为从前往后
5. 举例推导：

![img](https://code-thinking-1253855093.file.myqcloud.com/pics/20221026175104.png)



### 题解

```java
class Solution {
    public int minCostClimbingStairs(int[] cost) {
        int n = cost.length;
        int[] dp = new int[n + 1];
        dp[0] = 0;
        dp[1] = 0;
        for (int i = 2; i <= n; i++) {
            dp[i] = Math.min(dp[i - 1] + cost[i - 1], dp[i - 2] + cost[i - 2]);
        }
        return dp[n];
    }
}
```

