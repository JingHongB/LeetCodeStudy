## 目录

[134. 加油站](#1)

[135. 分发糖果](#2)

[860.柠檬水找零](#3)

[406.根据身高重建队列](#4)



## 134. 加油站<a id=1></a>

### 题目

[134. 加油站 - 力扣（LeetCode）](https://leetcode.cn/problems/gas-station/description/)

在一条环路上有 `n` 个加油站，其中第 `i` 个加油站有汽油 `gas[i]` 升。

你有一辆油箱容量无限的的汽车，从第 `i` 个加油站开往第 `i+1` 个加油站需要消耗汽油 `cost[i]` 升。你从其中的一个加油站出发，开始时油箱为空。

给定两个整数数组 `gas` 和 `cost` ，如果你可以按顺序绕环路行驶一周，则返回出发时加油站的编号，否则返回 `-1` 。如果存在解，则 **保证** 它是 **唯一** 的。

示例1：

```
输入: gas = [1,2,3,4,5], cost = [3,4,5,1,2]
输出: 3
解释:
从 3 号加油站(索引为 3 处)出发，可获得 4 升汽油。此时油箱有 = 0 + 4 = 4 升汽油
开往 4 号加油站，此时油箱有 4 - 1 + 5 = 8 升汽油
开往 0 号加油站，此时油箱有 8 - 2 + 1 = 7 升汽油
开往 1 号加油站，此时油箱有 7 - 3 + 2 = 6 升汽油
开往 2 号加油站，此时油箱有 6 - 4 + 3 = 5 升汽油
开往 3 号加油站，你需要消耗 5 升汽油，正好足够你返回到 3 号加油站。
因此，3 可为起始索引。
```

示例2：

```
输入: gas = [2,3,4], cost = [3,4,3]
输出: -1
解释:
你不能从 0 号或 1 号加油站出发，因为没有足够的汽油可以让你行驶到下一个加油站。
我们从 2 号加油站出发，可以获得 4 升汽油。 此时油箱有 = 0 + 4 = 4 升汽油
开往 0 号加油站，此时油箱有 4 - 3 + 2 = 3 升汽油
开往 1 号加油站，此时油箱有 3 - 3 + 3 = 3 升汽油
你无法返回 2 号加油站，因为返程需要消耗 4 升汽油，但是你的油箱只有 3 升汽油。
因此，无论怎样，你都不可能绕环路行驶一周。
```

**提示:**

- `gas.length == n`
- `cost.length == n`
- `1 <= n <= 105`
- `0 <= gas[i], cost[i] <= 104`



### 思路

[视频讲解：LeetCode ：134.加油站](https://www.bilibili.com/video/BV1jA411r7WX/)

[代码随想录：134.加油站](https://www.programmercarl.com/0134.加油站.html)

如果总油量 `totalGas` 小于总消耗 `totalCost`，则不可能绕环路一圈，直接返回 `-1`。

使用一个变量 `currentGas` 来表示当前油量，遍历所有的加油站。

如果在某个加油站 `j` 发现 `currentGas` 变为负数，则说明从起点 `i` 开始，**区间`[i, j]`中的任何一点都不能作为起始点**，因此将 `j` 的下一站作为新的起点继续尝试。

理由如下：如果 `curSum < 0` ，说明 `区间和1 + 区间和2 < 0`， 假设从下图中的箭头指向位置开始计数，`curSum > 0` ，即`区间和2 > 0`。

所以同时得到`区间和1 + 区间和2 < 0` 和 `区间和2 > 0`，最终可以推出 `区间和1 < 0`， 说明会从假设的箭头处开始选择新位置。

综上，只要遇到`currentGas < 0`，就可以直接将当前站点的下一站作为新的起点。 

<img src="https://code-thinking-1253855093.file.myqcloud.com/pics/20230117170703.png" alt="img"  />



### 题解

```java
class Solution {
    public int canCompleteCircuit(int[] gas, int[] cost) {
        int len = gas.length;
        int total = 0;
        int cur = 0;
        int index = 0;
        for (int i = 0; i < len; i++) {
            cur += gas[i] - cost[i];
            total += gas[i] - cost[i];
            if (cur < 0) {
                cur = 0;
                index = i + 1;
            }
        }
        if (total < 0)
            return -1;
        return index;
    }
}
```



## 135. 分发糖果<a id=2></a>

### 题目

[135. 分发糖果 - 力扣（LeetCode）](https://leetcode.cn/problems/candy/description/)

`n` 个孩子站成一排。给你一个整数数组 `ratings` 表示每个孩子的评分。

你需要按照以下要求，给这些孩子分发糖果：

- 每个孩子至少分配到 `1` 个糖果。
- 相邻两个孩子评分更高的孩子会获得更多的糖果。

请你给每个孩子分发糖果，计算并返回需要准备的 **最少糖果数目** 。

示例1：

```
输入：ratings = [1,0,2]
输出：5
解释：你可以分别给第一个、第二个、第三个孩子分发 2、1、2 颗糖果。
```

示例2：

```
输入：ratings = [1,2,2]
输出：4
解释：你可以分别给第一个、第二个、第三个孩子分发 1、2、1 颗糖果。
     第三个孩子只得到 1 颗糖果，这满足题面中的两个条件。
```

**提示：**

- n == ratings.length
- 1 <= n <= 2 * 10^4^
- 0 <= ratings[i] <= 2 * 10^4^

### 思路

[视频讲解：LeetCode：135.分发糖果](https://www.bilibili.com/video/BV1ev4y1r7wN/)

[代码随想录：135.分发糖果](https://www.programmercarl.com/0135.分发糖果.html)





### 题解

```

```



## 860.柠檬水找零<a id=3></a>

### 题目

[860. 柠檬水找零 - 力扣（LeetCode）](https://leetcode.cn/problems/lemonade-change/description/)

在柠檬水摊上，每一杯柠檬水的售价为 `5` 美元。顾客排队购买你的产品，（按账单 `bills` 支付的顺序）一次购买一杯。

每位顾客只买一杯柠檬水，然后向你付 `5` 美元、`10` 美元或 `20` 美元。你必须给每个顾客正确找零，也就是说净交易是每位顾客向你支付 `5` 美元。

注意，一开始你手头没有任何零钱。

给你一个整数数组 `bills` ，其中 `bills[i]` 是第 `i` 位顾客付的账。如果你能给每位顾客正确找零，返回 `true` ，否则返回 `false` 。

示例1：

```
输入：bills = [5,5,5,10,20]
输出：true
解释：
前 3 位顾客那里，我们按顺序收取 3 张 5 美元的钞票。
第 4 位顾客那里，我们收取一张 10 美元的钞票，并返还 5 美元。
第 5 位顾客那里，我们找还一张 10 美元的钞票和一张 5 美元的钞票。
由于所有客户都得到了正确的找零，所以我们输出 true。
```

示例2：

```
输入：bills = [5,5,10,10,20]
输出：false
解释：
前 2 位顾客那里，我们按顺序收取 2 张 5 美元的钞票。
对于接下来的 2 位顾客，我们收取一张 10 美元的钞票，然后返还 5 美元。
对于最后一位顾客，我们无法退回 15 美元，因为我们现在只有两张 10 美元的钞票。
由于不是每位顾客都得到了正确的找零，所以答案是 false。
```

**提示：**

- 1 <= bills.length <= 10^5^
- `bills[i]` 不是 `5` 就是 `10` 或是 `20` 



### 思路

[视频讲解：LeetCode：860.柠檬水找零](https://www.bilibili.com/video/BV12x4y1j7DD/)

[代码随想录：860.柠檬水找零](https://www.programmercarl.com/0860.柠檬水找零.html)

按题意模拟即可，注意收到 20 元时优先考虑用 10 元找零。



### 题解

```java
class Solution {
    public boolean lemonadeChange(int[] bills) {
        int five = 0, ten = 0;
        for (int i : bills) {
            if (i == 5) {
                five++;
            } else if (i == 10) {
                ten++;
                five--;
            } else {
                if (ten > 0) {
                    ten--;
                    five--;
                } else {
                    five -= 3;
                }
            }
            if (five < 0)
                return false;
        }
        return true;
    }
}
```



##  406.根据身高重建队列<a id=4></a>

### 题目

[406. 根据身高重建队列 - 力扣（LeetCode）](https://leetcode.cn/problems/queue-reconstruction-by-height/description/)

假设有打乱顺序的一群人站成一个队列，数组 `people` 表示队列中一些人的属性（不一定按顺序）。每个 `people[i] = [hi, ki]` 表示第 `i` 个人的身高为 `hi` ，前面 **正好** 有 `ki` 个身高大于或等于 `hi` 的人。

请你重新构造并返回输入数组 `people` 所表示的队列。返回的队列应该格式化为数组 `queue` ，其中 `queue[j] = [hj, kj]` 是队列中第 `j` 个人的属性（`queue[0]` 是排在队列前面的人）。

示例1：

```
输入：people = [[7,0],[4,4],[7,1],[5,0],[6,1],[5,2]]
输出：[[5,0],[7,0],[5,2],[6,1],[4,4],[7,1]]
解释：
编号为 0 的人身高为 5 ，没有身高更高或者相同的人排在他前面。
编号为 1 的人身高为 7 ，没有身高更高或者相同的人排在他前面。
编号为 2 的人身高为 5 ，有 2 个身高更高或者相同的人排在他前面，即编号为 0 和 1 的人。
编号为 3 的人身高为 6 ，有 1 个身高更高或者相同的人排在他前面，即编号为 1 的人。
编号为 4 的人身高为 4 ，有 4 个身高更高或者相同的人排在他前面，即编号为 0、1、2、3 的人。
编号为 5 的人身高为 7 ，有 1 个身高更高或者相同的人排在他前面，即编号为 1 的人。
因此 [[5,0],[7,0],[5,2],[6,1],[4,4],[7,1]] 是重新构造后的队列。
```

示例2：

```
输入：people = [[6,0],[5,0],[4,0],[3,2],[2,2],[1,4]]
输出：[[4,0],[5,0],[2,2],[3,2],[1,4],[6,0]]
```

**提示：**

- `1 <= people.length <= 2000`
- 0 <= hi <= 10^6^
- `0 <= ki < people.length`
- 题目数据确保队列可以被重建



### 思路

[视频讲解：LeetCode：406.根据身高重建队列](https://www.bilibili.com/video/BV1EA411675Y/)

[代码随想录：406.根据身高重建队列](https://www.programmercarl.com/0406.根据身高重建队列.html)







### 题解

```java
class Solution {
    public int[][] reconstructQueue(int[][] people) {
        Arrays.sort(people, (a, b) -> a[0] == b[0] ? a[1] - b[1] : b[0] - a[0]);
        List<int[]> queue = new LinkedList<>();
        for (int[] person : people) {
            queue.add(person[1], person);
        }
        return queue.toArray(new int[queue.size()][]);
    }
}
```

