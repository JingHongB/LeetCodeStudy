## 数组

### 数组理论基础

**数组是存放在连续内存空间上的相同类型数据的集合。**

数组可以通过下标索引的方式获取到下标对应的数据。

举一个字符数组的例子，如图所示：

![算法通关数组](https://code-thinking.cdn.bcebos.com/pics/%E7%AE%97%E6%B3%95%E9%80%9A%E5%85%B3%E6%95%B0%E7%BB%84.png)



有两点需要注意：

* **数组下标都是从0开始的。**
* **数组内存空间的地址是连续的**

**因为数组在内存空间的地址是连续的，所以在数组中删除或者增添元素的时候，难免要移动其他元素的地址。**

例如删除下标为3的元素，需要对下标为3的元素后面的所有元素都要做移动操作，如图所示：

![算法通关数组1](https://code-thinking.cdn.bcebos.com/pics/%E7%AE%97%E6%B3%95%E9%80%9A%E5%85%B3%E6%95%B0%E7%BB%841.png)

**数组的元素不能删除，只能覆盖。**

### 704.二分搜索

#### 题目

[704. 二分查找 - 力扣（LeetCode）](https://leetcode.cn/problems/binary-search/description/)

给定一个 n 个元素有序的（升序）整型数组 nums 和一个目标值 target  ，写一个函数搜索 nums 中的 target，如果目标值存在返回下标，否则返回 -1。

你可以假设 nums 中的所有元素是不重复的。

实例1：

```
输入: nums = [-1,0,3,5,9,12], target = 9     
输出: 4       
解释: 9 出现在 nums 中并且下标为 4 
```

实例2：

```text
输入: nums = [-1,0,3,5,9,12], target = 2     
输出: -1        
解释: 2 不存在 nums 中因此返回 -1 
```

#### 思路

[二分搜索算法详解-CSDN博客](https://blog.csdn.net/qq_44096670/article/details/111768372)

首先，了解二分搜索法的基本知识：

在一个有序数组中确定某个元素的位置时可以使用二分搜索法。

假设在[begin，end]范围内搜索某个元素 target，mid = （begin + end）/ 2

1. 如果target < mid，在[begin ， mid]范围内再次二分搜索
2. 如果target > mid，在[mid， end]范围内再次二分搜索
3. 如果target == mid ，直接返回 mid

[视频讲解：704. 二分查找](https://www.bilibili.com/video/BV1fA4y1o715)

本题题目的重点是**有序且无重复元素的数组**，满足使用二分搜索法的两个条件，每当看到这两个条件时，就可以考虑使用二分搜索法。

二分搜索的重点是确定边界条件，并且在使用过程中一直坚持区间定义进行操作。

一般有两种区间定义：

1. 左闭右闭，即 [left，right]
2. 左闭右开，即 [left，right)

#### 题解

[代码随想录：二分查找](https://www.programmercarl.com/0704.二分查找.html#算法公开课)

##### 方法一

方法一将区间定义为左闭右闭。

针对左闭右闭的区间，有三点需要注意：

1. 右闭区间，所以`right = nums.length - 1`
2. [left，right]中left与right可以相等，因此使用`while(left<=right)`。
3. if (nums[middle] > target) 情况中，right 要赋值为 middle - 1。因为是右闭区间，下一次进行二分查找时包含右边界，所以需要将右边界设置为nums[middle-1]。

实现代码：

```java
class Solution {
    public int search(int[] nums, int target) {
        int left = 0;
        int right = nums.length - 1;
        int middle = (left + right) / 2;
        while (left <= right) {
            middle = (left + right) / 2;
            if (nums[middle] < target) {
                left = middle + 1;
            } else if (nums[middle] > target) {
                right = middle - 1;
            } else if (nums[middle] == target) {
                return middle;
            }
        }
        return -1;
    }
}
```

- 时间复杂度：O(log n)
- 空间复杂度：O(1)

##### 方法二

方法二将区间定义为左闭右开。

针对左闭右开的区间，有三点需要注意：

1. 右开区间，所以`right = nums.length`
2. [left，right)中left与right不可以相等，因此使用`while(left<right)`。
3. if (nums[middle] > target) 情况中，right 要赋值为 middle。因为是右开区间，下一次进行二分查找时不会包含右边界，所以需要将右边界设置为nums[middle]。

实现代码：

```java
class Solution {
    public int search(int[] nums, int target) {
        int left = 0;
        int right = nums.length;
        int middle = (left + right) / 2;
        while (left < right) {
            middle = (left + right) / 2;
            if (nums[middle] < target) {
                left = middle + 1;
            } else if (nums[middle] > target) {
                right = middle;
            } else if (nums[middle] == target) {
                return middle;
            }
        }
        return -1;
    }
}
```

- 时间复杂度：O(log n)
- 空间复杂度：O(1)

#### 35.搜索插入位置

##### 题目

[35. 搜索插入位置 - 力扣（LeetCode）](https://leetcode.cn/problems/search-insert-position/description/)

给定一个升序数组和一个目标值，在数组中找到目标值，并返回其索引。如果目标值不存在于数组中，返回它将会被按顺序插入的位置。

你可以假设数组中无重复元素。

示例1：

```
输入: nums = [1,3,5,6], target = 5
输出: 2
```

示例2：

```
输入: [1,3,5,6], target = 2
输出: 1
```

示例3：

```
输入: [1,3,5,6], target = 7
输出: 4
```

示例4：

```
输入: [1,3,5,6], target = 0
输出: 0
```

##### 思路

看到题目中的条件是**无重复元素的有序数组**，目的是**查找某个元素**，第一反应使用二分搜索。

针对**“如果目标值不存在于数组中，返回它将会被按顺序插入的位置”**，可以得到有四种插入情况：

<img src="https://code-thinking-1253855093.file.myqcloud.com/pics/20201216232148471.png" alt="35_搜索插入位置3" style="zoom:75%;float:left" />

1. 目标值等于数组中某一个元素
2. 目标值在数组所有元素之前
3. 目标值插入数组中的某个位置
4. 目标值在数组所有元素之后

##### 题解

[代码随想录 ：搜索插入位置](https://programmercarl.com/0035.搜索插入位置.html)

独立解题如下：

```java
class Solution {
    public int searchInsert(int[] nums, int target) {
        //基本的二分查找，此处采用左闭右闭方法
        int left = 0;
        int right = nums.length - 1;
        int middle = (left + right) / 2;
        while (left <= right) {
            middle = (left + right) / 2;
            if (nums[middle] < target) {
                left = middle + 1;
            } else if (nums[middle] > target) {
                right = middle - 1;
            } else if (nums[middle] == target) {
                return middle;
            }
        }
        //判断插入位置，返回不同的值
        if (middle == 0 && nums[middle] > target) {
            return 0;
        } else if (middle == nums.length - 1 && nums[middle] < target) {
            return nums.length;
        } else if (middle == 0 && nums[middle] < target) {
            return 1;
        } else if (middle == nums.length - 1 && nums[middle] > target) {
            return nums.length - 1;
        } else if (nums[middle] > target) {
            return middle;
        } else {
            return middle + 1;
        }
    }
}
```

观看正确题解之后得到：

```java
class Solution {
    public int searchInsert(int[] nums, int target) {
        int left = 0;
        int right = nums.length - 1;
        int middle = (left + right) / 2;
        while (left <= right) {
            middle = (left + right) / 2;
            if (nums[middle] < target) {
                left = middle + 1;
            } else if (nums[middle] > target) {
                right = middle - 1;
            } else if (nums[middle] == target) {
                //1.目标值等于数组中某一个元素
                return middle;
            }
        }
        //2.目标值在数组所有元素之前：left=0,right=-1,返回right+1=0
        //3.目标值插入数组中的某个位置：right=left-1,nums[left]>target,nums[right]<target,返回right+1
        //4.目标值在数组所有元素之后：right=nums.length-1,返回right+1=nums.length
        //三种情况得到相同返回值
        return right + 1;
    }
}
```

总结：针对不同情况时，正确找出相同点并进行归纳。

#### 34.在排序数组中查找元素的第一个和最后一个位置

##### 题目

[34. 在排序数组中查找元素的第一个和最后一个位置 - 力扣（LeetCode）](https://leetcode.cn/problems/find-first-and-last-position-of-element-in-sorted-array/description/)

给定一个按照升序排列的整数数组 nums，和一个目标值 target。找出给定目标值在数组中的开始位置和结束位置。

如果数组中不存在目标值 target，返回 [-1, -1]。

设计并实现时间复杂度为 `O(log n)` 的算法解决此问题。

示例1：

```
输入：nums = [5,7,7,8,8,10], target = 8
输出：[3,4]
```

示例2：

```
输入：nums = [5,7,7,8,8,10], target = 6
输出：[-1,-1]
```

示例3：

```
输入：nums = [], target = 0
输出：[-1,-1]
```

##### 思路

由题目中的**升序排列数组**，可以使用二分法。

个人思路：使用二分法找到一个位于任意位置的target，未找到则返回[-1,-1]，若找到target，则从找到的target位置分别向左右两边延申并判断是否等于target，找到相应的边界，找到后返回[left，right]

问题如下：

1. 第一次提交没有考虑数组下标越界情况，即出现了nums[-1]的情况。
2. 修改之后成功提交，在学习他人题解讨论时发现，如果用例所给数组为被target填满的数组，此时最坏时间复杂度为O(1)，不满足题目要求，虽然第二次提交通过，但仍是错解。



查阅各种题解后，总结思路：使用两次二分查找，先找到第一个等于target的位置，再找最后一个等于target的位置。

##### 题解

[代码随想录：在排序数组中查找元素的第一个和最后一个位置](https://programmercarl.com/0034.在排序数组中查找元素的第一个和最后一个位置.html)

独立错误题解：

```java
class Solution {
    public int[] searchRange(int[] nums, int target) {
        int left = 0;
        int right = nums.length - 1;
        int mid = 0;
        while (left <= right) {
            mid = left + (right - left) / 2;
            if (nums[mid] < target) {
                left = mid + 1;
            } else if (nums[mid] > target) {
                right = mid - 1;
            } else {
                //当搜索到任意target时，向左右两端进行延申，直到下一个元素不等于target。
                //问题：当数组中所有元素都为target时，时间复杂度为O(1)。
                int l = mid;
                int r = mid;
                while (nums[l] == target) {
                    l--;
                    if (l == -1) {
                        break;
                    }
                }
                while (nums[r] == target) {
                    r++;
                    if (r == nums.length) {
                        break;
                    }
                }
                return new int[] { l + 1, r - 1 };
            }
        }
        return new int[] { -1, -1 };
    }
}
```

修改后题解：

```java
class Solution {
    public int[] searchRange(int[] nums, int target) {
        int left = 0;
        int right = nums.length - 1;
        int mid = 0;
        //存放下标
        int first = -1;
        int last = -1;
        //第一次使用二分法，查询第一个target的位置
        while (left <= right) {
            mid = left + (right - left) / 2;
            if (nums[mid] == target) {
                //**重点**：修改右边界，在搜索到的target左方继续搜索target
                right = mid - 1;
                //修改first，即第一个target的下标位置
                first = mid;
            //正常使用二分法过程
            } else if (nums[mid] < target) {
                left = mid + 1;
            } else if (nums[mid] > target) {
                right = mid - 1;
            }
        }
        //重置左右边界，第二次使用二分法，查询最后一个target的位置
        left = 0;
        right = nums.length - 1;
        while (left <= right) {
            mid = left + (right - left) / 2;
            if (nums[mid] == target) {
                //**重点**：修改左边界，在搜索到的target右方继续搜索target
                left = mid + 1;
                //修改last，即最后一个target的下标位置
                last = mid;
            //正常使用二分法过程
            } else if (nums[mid] < target) {
                left = mid + 1;
            } else if (nums[mid] > target) {
                right = mid - 1;
            }
        }
        return new int[] { first, last };
    }
}
```



#### 69.x的平方根

##### 题目

[[69. x 的平方根 - 力扣（LeetCode）](https://leetcode.cn/problems/sqrtx/description/)](https://leetcode.cn/problems/sqrtx/description/)

给一个非负整数 `x` ，计算并返回 `x` 的 **算术平方根** 。

由于返回类型是整数，结果只保留 **整数部分** ，小数部分将被 **舍去 。**

**注意：**不允许使用任何内置指数函数和算符，例如 `pow(x, 0.5)` 或者 `x ** 0.5` 。

示例1：

```
输入：x = 4
输出：2
```

示例2：

```
输入：x = 8
输出：2
解释：8 的算术平方根是 2.82842..., 由于返回类型是整数，小数部分将被舍去。
```

提示：

- 0 <= x <= 2^31^ - 1

##### 思路

因为x平方根的整数部分ans是满足k^2^<=x的最大k，因此可以对k进行二分查找得到答案。

可以将二分查找的左边界设置为0，将右边界粗略地设置为x，在使用二分查找的过程中，不断将middle的平方与x进行大小比较，调整上下界的范围。

##### 题解

独立完成的题解仅能通过较小的x用例，遭遇较大的x用例时无法通过，初步判断为middle的平方超过了int类型的取值范围。

解决方法为将middle的平方类型转换为浮点型。

独立题解如下：

```java
class Solution {
    public int mySqrt(int x) {
        int left = 0;
        int right = x;
        int middle = 0;
        while (left <= right) {
            middle = left + (right - left) / 2;
            //使用强制类型转换
            if ((long) middle * middle < x) {
                left = middle + 1;
            } else if ((long) middle * middle > x) {
                right = middle - 1;
            } else if ((long) middle * middle == x) {
                return middle;
            }
        }
        return right;
    }
}
```

官方题解如下：

```java
class Solution {
    public int mySqrt(int x) {
        //使用ans存储目标值
        int l = 0, r = x, ans = -1;
        while (l <= r) {
            int mid = l + (r - l) / 2;
            if ((long) mid * mid <= x) {
                ans = mid;
                l = mid + 1;
            } else {
                r = mid - 1;
            }
        }
        return ans;
    }
}
```

#### 367.有效的完全平方数

##### 题目

[367. 有效的完全平方数 - 力扣（LeetCode）](https://leetcode.cn/problems/valid-perfect-square/description/)

给一个正整数 `num` 。如果 `num` 是一个完全平方数，则返回 `true` ，否则返回 `false` 。

**完全平方数** 是一个可以写成某个整数的平方的整数。换句话说，它可以写成某个整数和自身的乘积。

不能使用任何内置的库函数，如 `sqrt` 。

示例1：

```
输入：num = 16
输出：true
解释：返回 true ，因为 4 * 4 = 16 且 4 是一个整数。
```

示例2：

```
输入：num = 14
输出：false
解释：返回 false ，因为 3.742 * 3.742 = 14 但 3.742 不是一个整数。
```

提示：

- 0 <= num <= 2^31^ - 1

##### 思路

首先，可以考虑暴力解法，从1开始遍历所有正整数，直到找到满足x^2^=num的正整数，则返回true，如果出现x^2^>num，则返回false。

还可以使用二分法，左边界设置为0，右边界设置为num，持续使用二分法判断middle^2^与num的大小。

由题给出的num的范围，可以得到计算middle^2^的时候，需要使用强制类型转换为浮点型，再与num进行比较。

本人此题使用二分法。

##### 题解

题解如下：

```java
class Solution {
    public boolean isPerfectSquare(int num) {
        int left = 0;
        int right = num;
        int mid = 0;
        while (left <= right) {
            mid = left + (right - left) / 2;
            //得到num为mid的平方，返回true
            if ((long) mid * mid == num) {
                return true;
            } else if ((long) mid * mid > num) {
                right = mid - 1;
            } else {
                left = mid + 1;
            }
        }
        //二分搜索结束都没有找到相应的x，返回false
        return false;
    }
}
```



### 27.移除元素

#### 题目

[27. 移除元素 - 力扣（LeetCode）](https://leetcode.cn/problems/remove-element/description/)

给你一个数组 `nums` 和一个值 `val`，你需要 **原地** 移除所有数值等于 `val` 的元素。元素的顺序可能发生改变。然后返回 `nums` 中与 `val` 不同的元素的数量。

假设 `nums` 中不等于 `val` 的元素数量为 `k`，要通过此题，您需要执行以下操作：

- 更改 `nums` 数组，使 `nums` 的前 `k` 个元素包含不等于 `val` 的元素。`nums` 的其余元素和 `nums` 的大小并不重要。
- 返回 `k`。

示例1：

```
输入：nums = [3,2,2,3], val = 3
输出：2, nums = [2,2,_,_]
解释：你的函数函数应该返回 k = 2, 并且 nums 中的前两个元素均为 2。
你在返回的 k 个元素之外留下了什么并不重要（因此它们并不计入评测）。
```

示例2：

```
输入：nums = [0,1,2,2,3,0,4,2], val = 2
输出：5, nums = [0,1,4,0,3,_,_,_]
解释：你的函数应该返回 k = 5，并且 nums 中的前五个元素为 0,0,1,3,4。
注意这五个元素可以任意顺序返回。
你在返回的 k 个元素之外留下了什么并不重要（因此它们并不计入评测）。
```

#### 思路

[视频讲解：27. 移除元素](https://www.bilibili.com/video/BV12A4y1Z7LP)

重点：数组的元素在内存地址中是连续的，不能单独删除数组中的某个元素，只能对元素进行覆盖。

看到题目第一眼想到暴力解法：使用嵌套for循环，第一个for循环遍历数组元素，第二个for循环更新数组。

暴力解法时间复杂度为O(n^2^)，删除过程如下：

![27.移除元素-暴力解法](https://code-thinking.cdn.bcebos.com/gifs/27.%E7%A7%BB%E9%99%A4%E5%85%83%E7%B4%A0-%E6%9A%B4%E5%8A%9B%E8%A7%A3%E6%B3%95.gif)

[一文看懂快慢指针-CSDN博客](https://blog.csdn.net/softpoeter/article/details/103153564)

快慢指针法：通过一个快指针和一个慢指针在一个for循环下完成两个for循环的工作。

定义快慢指针如下：

- 快指针：寻找新数组中的元素，即与目标值不相等的元素。
- 慢指针：指向更新新数组下标的位置。

时间复杂度为O(n)，过程如下：

![27.移除元素-双指针法](https://code-thinking.cdn.bcebos.com/gifs/27.%E7%A7%BB%E9%99%A4%E5%85%83%E7%B4%A0-%E5%8F%8C%E6%8C%87%E9%92%88%E6%B3%95.gif)

#### 题解

[代码随想录：移除元素](https://www.programmercarl.com/0027.移除元素.html#思路)

快慢指针法：

```java
class Solution {
    public int removeElement(int[] nums, int val) {
        int slow = 0;
        for (int fast = 0; fast < nums.length; fast++) {
            if (nums[fast] != val) {
                nums[slow] = nums[fast];
                slow++;
            }
        }
        return slow;
    }
}
```

暴力解法：

```java
class Solution {
    public int removeElement(int[] nums, int val) {
        //size为新数组的长度
        int size = nums.length;
        for (int i = 0; i < size; i++) {
            if (nums[i] == val) {
                for (int j = i + 1; j < size; j++) {
                    nums[j - 1] = nums[j];
                }
                //每去除一个元素，下标i之后的元素都向前移动一位，因此i也需要向前移动一位。
                i--;
                //每去除一个元素，新数组长度减一。
                size--;
            }
        }
        return size;
    }
}
```

#### 283.移动零

##### 题目

[283. 移动零 - 力扣（LeetCode）](https://leetcode.cn/problems/move-zeroes/description/)

给定一个数组 `nums`，编写一个函数将所有 `0` 移动到数组的末尾，同时保持非零元素的相对顺序。

**请注意** ，必须在不复制数组的情况下原地对数组进行操作。

示例1：

```
输入: nums = [0,1,0,3,12]
输出: [1,3,12,0,0]
```

示例2：

```
输入: nums = [0]
输出: [0]
```

##### 思路

[代码随想录：移动零](https://www.programmercarl.com/0283.移动零.html)

首先可以使用暴力解法：两层for循环，模拟删除数组元素的过程。

其次，可以想到使用快慢指针法，类似于移除元素0，唯一的区别是移除完之后将慢指针之后的元素都赋值为0。

##### 题解

独立题解：

```java
class Solution {
    public void moveZeroes(int[] nums) {
        int slow = 0;
        for (int fast = 0; fast < nums.length; fast++) {
            if (nums[fast] != 0) {
                nums[slow] = nums[fast];
                slow++;
            }
        }
        //将慢指针后的元素赋值为0
        for (int i = slow; i < nums.length; i++) {
            nums[i] = 0;
        }
    }
}
```

改为一次遍历：

```java
class Solution {
    public void moveZeroes(int[] nums) {
        int slow = 0;
        for (int fast = 0; fast < nums.length; fast++) {
            if (nums[fast] != 0) {
                //直接交换快指针与慢指针元素的位置，可以将0交换到数组末尾。
                int tmp = nums[slow];
                nums[slow] = nums[fast];
                nums[fast] = tmp;
                slow++;
            }
        }
    }
}
```

#### 26.删除有序数组中的重复项

##### 题目

给你一个 **非严格递增排列** 的数组`nums`，请你**原地**删除重复出现的元素，使每个元素**只出现一次**，返回删除后数组的新长度。元素的**相对顺序**应该保持 **一致** 。然后返回`nums`中唯一元素的个数。

考虑`nums`的唯一元素的数量为`k`，你需要做以下事情确保你的题解可以被通过：

- 更改数组`nums`，使`nums`的前`k`个元素包含唯一元素，并按照它们最初在`nums`中出现的顺序排列。`nums`的其余元素与`nums`的大小不重要。
- 返回`k`。

示例1：

```
输入：nums = [1,1,2]
输出：2, nums = [1,2,_]
解释：函数应该返回新的长度 2 ，并且原数组 nums 的前两个元素被修改为 1, 2 。不需要考虑数组中超出新长度后面的元素。
```

示例2：

```
输入：nums = [0,0,1,1,1,2,2,3,3,4]
输出：5, nums = [0,1,2,3,4]
解释：函数应该返回新的长度 5 ， 并且原数组 nums 的前五个元素被修改为 0, 1, 2, 3, 4 。不需要考虑数组中超出新长度后面的元素。
```

##### 思路

由题**有序数组**，可得重复元素一定相邻。

要删除重复元素，实质是将不重复的元素都移到数组左侧。

可以使用双指针法，分别定义快慢指针fast和slow。

比较fast和slow大小：

- 如果相等，fast向后移动一位
- 如果不相等，将fast上的元素赋值到slow+1上，slow和fast都向后移动一位

<img src="https://pic.leetcode-cn.com/1631552114-iGjdpt-%E5%BF%AB%E6%85%A2%E6%8C%87%E9%92%88.png" alt="快慢指针.png" style="zoom: 50%;" />

##### 题解

```java
class Solution {
    public int removeDuplicates(int[] nums) {
        int slow = 0;
        int fast = 0;
        //新数组长度
        int k = 1;
        for (fast = 0; fast < nums.length; fast++) {
            if (nums[fast] != nums[slow]) {
                k++;
                slow++;
                nums[slow] = nums[fast];
            }
        }
        return k;
    }
}
```



### 977.有序数组的平方

#### 题目

[977. 有序数组的平方 - 力扣（LeetCode）](https://leetcode.cn/problems/squares-of-a-sorted-array/description/)

给你一个按 **非递减顺序** 排序的整数数组 `nums`，返回 **每个数字的平方** 组成的新数组，要求也按 **非递减顺序** 排序。

示例1：

```
输入：nums = [-4,-1,0,3,10]
输出：[0,1,9,16,100]
解释：平方后，数组变为 [16,1,0,9,100]
排序后，数组变为 [0,1,9,16,100]
```

示例2：

```
输入：nums = [-7,-3,2,3,11]
输出：[4,9,9,49,121]
```

#### 思路

[视频讲解：977.有序数组的平方](https://www.bilibili.com/video/BV1QB4y1D7ep)

第一眼依然是最直观的暴力解法：先将所有元素平方，再进行排序。

暴力解法虽然直观，但是时间复杂度较高，为O(n+nlogn)。

由题目得到**非递减数组**，且**包含负数**，可以得到平方值最大的元素一定在数组两端，而不是在数组中间，此时可以考虑使用双指针法。

左指针指向起始位置，右指针指向终止位置。

定义一个相同大小的新数组result用于存放排序后的元素。

因为要求**非递减顺序排列**，创建指针k指向新数组的终止位置，每次添加新元素后指针向前移动一位。

过程如下：

![img](https://code-thinking.cdn.bcebos.com/gifs/977.%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%E7%9A%84%E5%B9%B3%E6%96%B9.gif)

#### 题解

[代码随想录 ：有序数组的平方](https://www.programmercarl.com/0977.有序数组的平方.html)

双指针法：

```java
class Solution {
    public int[] sortedSquares(int[] nums) {
        int[] result = new int[nums.length];
        int left = 0;
        int right = nums.length - 1;
        int k = nums.length - 1;
        while (left <= right) {
            //比较平方值大小，将较大值添加到新数组中，同时根据不同情况移动left或right指针
            if (nums[left] * nums[left] >= nums[right] * nums[right]) {
                result[k--] = nums[left] * nums[left];
                left++;
            } else {
                result[k--] = nums[right] * nums[right];
                right--;
            }
        }
        return result;
    }
}
```

暴力解法：

```java
class Solution {
    public int[] sortedSquares(int[] nums) {
        int[] ans = new int[nums.length];
        for (int i = 0; i < nums.length; ++i) {
            ans[i] = nums[i] * nums[i];
        }
        Arrays.sort(ans);
        return ans;
    }
}
```

### 209.长度最小的子数组

#### 题目

[209. 长度最小的子数组 - 力扣（LeetCode）](https://leetcode.cn/problems/minimum-size-subarray-sum/description/)

给定一个含有 `n` 个正整数的数组和一个正整数 `target` **。**

找出该数组中满足其总和大于等于 `target` 的长度最小的 子数组`[numsl, numsl+1, ..., numsr-1, numsr]` ，并返回其长度**。**如果不存在符合条件的子数组，返回 `0` 。

示例1：

```
输入：target = 7, nums = [2,3,1,2,4,3]
输出：2
解释：子数组 [4,3] 是该条件下的长度最小的子数组。
```

示例2：

```
输入：target = 4, nums = [1,4,4]
输出：1
```

示例3：

```
输入：target = 11, nums = [1,1,1,1,1,1,1,1]
输出：0
```

#### 思路

[视频讲解：209.长度最小的子数组](https://www.bilibili.com/video/BV1tZ4y1q7XE)

暴力解法：使用两个for循环，一个for循环起始位置，另一个循环终止位置，不断寻找符合条件的子序列，时间复杂度O(n^2^)。

[滑动窗口法总结_滑窗法-CSDN博客](https://blog.csdn.net/Dby_freedom/article/details/89066140)

滑动窗口，即**不断调节子序列的起始位置和终止位置**，从而得到所需要的结果。

只使用一个for循环，该循环的索引表示子序列的终止位置，查找过程如下：

![209.长度最小的子数组](https://code-thinking.cdn.bcebos.com/gifs/209.%E9%95%BF%E5%BA%A6%E6%9C%80%E5%B0%8F%E7%9A%84%E5%AD%90%E6%95%B0%E7%BB%84.gif)

由过程演示发现滑动窗口可以理解为双指针法的一种。

在本题中实现滑动窗口，要确定如下三点：

1. 窗口内是什么？
2. 如何移动窗口的起始位置？
3. 如何移动窗口的终止位置？

理解：

1. 窗口是满足sum>=target的长度最小的子序列。
2. 当前窗口满足sum>=target时，向右移动起始位置（即缩小窗口）。
3. 窗口的终止位置即遍历数组的指针，也就是for循环中的索引。

解题关键在于起始位置的移动，如图：

<img src="https://code-thinking-1253855093.file.myqcloud.com/pics/20210312160441942.png" alt="leetcode_209" style="zoom:80%;" />

滑动窗口的精妙之处在于**根据当前子序列和大小的情况，不断调节子序列的起始位置**。

时间复杂度从暴力解法的O(n^2^)降为O(n)。

#### 题解

[代码随想录：长度最小的子数组](https://www.programmercarl.com/0209.长度最小的子数组.html#思路)

滑动窗口：

```java
class Solution {
    public int minSubArrayLen(int target, int[] nums) {
        int start = 0;
        int end = 0;
        //ans设置为大于数组长度的数字，用来与子序列长度作比较
        //也可以设置为Integer.MAX_VALUE
        int ans = nums.length + 1;
        int sum = 0;
        for (end = 0; end < nums.length; end++) {
            //根据end的移动，向sum中加元素
            sum += nums[end];
            //当sum>=target时，移动start位置
            //注意要使用while循环，因为有可能需要多次移动start位置
            while (sum >= target) {
                //获取ans与新子序列长度的较小值
                ans = Math.min(ans, end - start + 1);
                sum -= nums[start++];
            }
        }
        //判断ans是否改变，即是否存在符合条件的子序列
        return ans == nums.length + 1 ? 0 : ans;
    }
}
```

暴力解法：

```java
class Solution {
    public int minSubArrayLen(int s, int[] nums) {
        int n = nums.length;
        if (n == 0) {
            return 0;
        }
        int ans = Integer.MAX_VALUE;
        //两层for循环
        for (int i = 0; i < n; i++) {
            int sum = 0;
            for (int j = i; j < n; j++) {
                sum += nums[j];
                if (sum >= s) {
                    ans = Math.min(ans, j - i + 1);
                    break;
                }
            }
        }
        return ans == Integer.MAX_VALUE ? 0 : ans;
    }
}
```

#### 904.水果成篮

##### 题目

[904. 水果成篮 - 力扣（LeetCode）](https://leetcode.cn/problems/fruit-into-baskets/description/)

你正在探访一家农场，农场从左到右种植了一排果树。这些树用一个整数数组 `fruits` 表示，其中 `fruits[i]` 是第 `i` 棵树上的水果 **种类** 。

你想要尽可能多地收集水果。然而，农场的主人设定了一些严格的规矩，你必须按照要求采摘水果：

- 你只有 **两个** 篮子，并且每个篮子只能装 **单一类型** 的水果。每个篮子能够装的水果总量没有限制。
- 你可以选择任意一棵树开始采摘，你必须从 **每棵** 树（包括开始采摘的树）上 **恰好摘一个水果** 。采摘的水果应当符合篮子中的水果类型。每采摘一次，你将会向右移动到下一棵树，并继续采摘。
- 一旦你走到某棵树前，但水果不符合篮子的水果类型，那么就必须停止采摘。

给你一个整数数组 `fruits` ，返回你可以收集的水果的 **最大** 数目。

示例1：

```
输入：fruits = [1,2,1]
输出：3
解释：可以采摘全部 3 棵树。
```

示例2：

```
输入：fruits = [0,1,2,2]
输出：3
解释：可以采摘 [1,2,2] 这三棵树。
如果从第一棵树开始采摘，则只能采摘 [0,1] 这两棵树。
```

示例3：

```
输入：fruits = [1,2,3,2,2]
输出：4
解释：可以采摘 [2,3,2,2] 这四棵树。
如果从第一棵树开始采摘，则只能采摘 [1,2] 这两棵树。
```

示例4：

```
输入：fruits = [3,3,3,1,2,1,1,2,3,3,4]
输出：5
解释：可以采摘 [1,2,1,1,2] 这五棵树。
```

提示：

- `1 <= fruits.length <= 105`
- `0 <= fruits[i] < fruits.length`

##### 思路

理解题意：从任意位置开始，**同时使用**两个篮子采集水果，一旦选择后不能修改篮子所装的水果种类，当所有树处理完或遇到第一棵种类不同的树则停止。

初见思路：使用滑动窗口，定义快慢指针，再定义一个数组存放篮子中的水果类型，当快指针遇到不在篮子中的水果类型时，将**慢指针所在位置的水果**替换为**快指针所在位置的水果**，再向右逐个移动慢指针，移动条件为**慢指针水果类型不在篮子中**。

遇到的问题：输入条件为[3,3,3,1,2,1,1,2,3,3,4]时，当子序列[1,2,1,1,2,3]时，慢指针移动后子序列会变成[2,1,1,2,3]。

改进思路：直接将慢指针移动到快指针左侧一格，再从右往左移动，判断条件为**左侧一格水果**是否与**慢指针当前位置水果**相同。

原理：因为篮子中只有两种水果，**快指针所在位置的水果**在子序列中一定只出现那一次，而另一个篮子里的水果一定位于**快指针左侧一格**，如果子序列长度不止为2，左侧的水果一定与**快指针左侧一格**相等。



查阅力扣题解：

1. 创建一个水果数组，下标代表水果种类，元素表示水果在篮子中的数量。
2. 快指针移动时，新水果数量++。
3. 判断新位置的水果之前是否在篮子里，若不在则种类数++。
4. 当种类数>2时进入循环，慢指针移动，且旧水果数量--。
5. 判断旧位置的水果是否还在篮子里，若不在则种类数--，若在则继续循环。
6. Max

##### 题解

错误题解：

```java
class Solution {
    public int totalFruit(int[] fruits) {
        int left = 0;
        int right = 0;
        int ans = 0;
        int[] type = new int[2];
        type[0] = fruits[0];
        type[1] = -1;
        for(right = 0; right<fruits.length; right++){
            if(type[1]==-1&&fruits[right]!=type[0]){
                type[1] = fruits[right];
            }
            if(fruits[right]!=type[0]&&fruits[right]!=type[1]){
                type[0] = fruits[right-1];
                type[1] = fruits[right];
                //错误点
                while(fruits[left]!=type[0]&&fruits[left]!=type[1]){
                    left++;
                }
            }
            ans=Math.max(ans,right - left +1);
        }
        return ans;
    }
}
```

独立正确题解：

```java
class Solution {
    public int totalFruit(int[] fruits) {
        //快慢指针
        int left = 0;
        int right = 0;
        //答案值
        int ans = 0;
        //存放水果种类
        int[] type = new int[2];
        //设置第一个篮子放第一棵树的水果
        type[0] = fruits[0];
        //设置第二个篮子暂时不放水果
        type[1] = -1;
        //快指针先移动
        for (right = 0; right < fruits.length; right++) {
            //首次遇到与第一棵树不同的水果类型，将其放入第二个篮子中
            if (type[1] == -1 && fruits[right] != type[0]) {
                type[1] = fruits[right];
            }
            if (fruits[right] != type[0] && fruits[right] != type[1]) {
                //遇到不在篮子中的水果类型时，替换水果类型
                type[0] = fruits[right - 1];
                type[1] = fruits[right];
                //将慢指针移到到快指针左侧
                left = right - 1;
                //判断更换水果类型后，慢指针所在的位置
                while (fruits[left - 1] == fruits[left]) {
                    left--;
                }
            }
            //通过比较得到最大子序列
            ans = Math.max(ans, right - left + 1);
        }
        return ans;
    }
}
```

力扣题解1：

```java
 class Solution {
    public int totalFruit(int[] fruits) {
        // 返回值
        int totol = 0; 
        // 滑动条件：窗口内的种类数
        int cate = 0;  
        // 各种水果的计数
        int[] nums = new int[fruits.length+10];
        for(int left=0,right=0; right < fruits.length; right++){
            //  右累加
            if(++nums[ fruits[right] ] == 1) 
                cate++; //  计数累加 + 新品种类++
            //  左滑动
            while(cate>2){
                if(--nums[ fruits[left++] ] == 0) 
                    cate--;//  计数减少 + 减空的种类--
            }
            //  通过比较获取较大值
            totol = Math.max(totol, right-left+1);
        }
        return totol;
    }
}
```

力扣解题2（哈希表）：

```java
class Solution {
    public int totalFruit(int[] fruits) {
        int n = fruits.length;
        Map<Integer, Integer> cnt = new HashMap<Integer, Integer>();

        int left = 0, ans = 0;
        for (int right = 0; right < n; ++right) {
            cnt.put(fruits[right], cnt.getOrDefault(fruits[right], 0) + 1);
            while (cnt.size() > 2) {
                cnt.put(fruits[left], cnt.get(fruits[left]) - 1);
                if (cnt.get(fruits[left]) == 0) {
                    cnt.remove(fruits[left]);
                }
                ++left;
            }
            ans = Math.max(ans, right - left + 1);
        }
        return ans;
    }
}
```



### 59.螺旋矩阵Ⅱ

#### 题目

[59. 螺旋矩阵 II - 力扣（LeetCode）](https://leetcode.cn/problems/spiral-matrix-ii/)

给你一个正整数 n ，生成一个包含 1 到 n^2^ 所有元素，且元素按顺时针顺序螺旋排列的 n x n 正方形矩阵 matrix 。

示例1：

<img src="https://assets.leetcode.com/uploads/2020/11/13/spiraln.jpg" alt="img" style="zoom: 67%;float:left" />

```
输入：n = 3
输出：[[1,2,3],[8,9,4],[7,6,5]]
```

示例2：

```
输入：n = 1
输出：[[1]]
```

#### 思路

模拟顺时针画矩阵的过程:

- 从左到右填充上行
- 从上到下填充右列
- 从右到左填充下行
- 从下到上填充左列

由外向内一圈一圈填充。

按照左闭右开的原则进行填充：

<img src="https://code-thinking-1253855093.file.myqcloud.com/pics/20220922102236.png" alt="img" style="zoom: 40%;" />



#### 题解

```java
class Solution {
    public int[][] generateMatrix(int n) {
        int[][] matrix = new int[n][n];
        //定义每一圈的起始位置
        int startX = 0,startY = 0;
        //用于控制每一次遍历边的长度
        int offset = 1;
        //填写的数字
        int num = 1;
        //行列数
        int i = 0, j = 0;
        while (num < n * n) {
            //确定起始点
            i = startX;
            j = startY;
            //上行从左往右
            for (; j < n - offset; j++) {
                matrix[i][j] = num++;
            }
            //右列从上往下
            for (; i < n - offset; i++) {
                matrix[i][j] = num++;
            }
            //下行从右往左
            for (; j > startY; j--) {
                matrix[i][j] = num++;
            }
            //左列从下往上
            for (; i > startX; i--) {
                matrix[i][j] = num++;
            }
            //下一次遍历边的长度减小
            offset++;
            //起始位置改变
            startX++;
            startY++;
        }
        //当n为奇数时，需要单独给最中间的一格赋值
        if (n % 2 == 1) {
            matrix[n / 2][n / 2] = n * n;
        }
        return matrix;
    }
}
```



## 链表

### 链表理论基础

#### 链表基础

链表是一种通过指针串联在一起的线性结构，每一个节点由两部分组成，分别是数据域和指针域（存放指向下一个节点的指针），最后一个节点的指针域指向null（空指针的意思）。

链表的入口节点称为链表的头结点也就是head。

如图所示：

![链表1](https://code-thinking-1253855093.file.myqcloud.com/pics/20200806194529815.png)

#### 链表类型

##### 单链表

上面介绍的就是单链表

##### 双链表	

单链表中的指针域只能指向节点的下一个节点。

双链表：每一个节点有两个指针域，一个指向下一个节点，一个指向上一个节点。

双链表既可以向前查询也可以向后查询。

如图所示：

![链表2](https://code-thinking-1253855093.file.myqcloud.com/pics/20200806194559317.png)

##### 循环链表

循环链表，顾名思义，就是链表首尾相连。

循环链表可以用来解决约瑟夫环问题。

![链表4](https://code-thinking-1253855093.file.myqcloud.com/pics/20200806194629603.png)

#### 存储方式

数组是在内存中是连续分布的，但是链表在内存中可不是连续分布的。

链表是通过指针域的指针链接在内存中各个节点。

所以链表中的节点在内存中不是连续分布的 ，而是散乱分布在内存中的某地址上，分配机制取决于操作系统的内存管理。

如图所示：

![链表3](https://code-thinking-1253855093.file.myqcloud.com/pics/20200806194613920.png)

这个链表起始节点为2， 终止节点为7， 各个节点分布在内存的不同地址空间上，通过指针串联在一起。

#### 链表的定义

```java
public class ListNode {
    // 结点的值
    int val;

    // 下一个结点
    ListNode next;

    // 节点的构造函数(无参)
    public ListNode() {
    }

    // 节点的构造函数(有一个参数)
    public ListNode(int val) {
        this.val = val;
    }

    // 节点的构造函数(有两个参数)
    public ListNode(int val, ListNode next) {
        this.val = val;
        this.next = next;
    }
}
```

#### 链表的操作

##### 删除节点

删除D节点，如图所示：

![链表-删除节点](https://code-thinking-1253855093.file.myqcloud.com/pics/20200806195114541-20230310121459257.png)

将C节点的next指针指向E节点即可。

Java有自己的内存回收机制，不需要手动释放D节点的内存。

##### 添加节点

如图所示：

![链表-添加节点](https://code-thinking-1253855093.file.myqcloud.com/pics/20200806195134331-20230310121503147.png)

可以看出链表的增添和删除都是O(1)操作，也不会影响到其他节点。

注意：如果删除的是第五个节点，需要从头节点查找到第四个节点通过next指针进行删除操作，查找的时间复杂度是O(n)。

#### 性能分析

表的特性和数组的特性进行一个对比，如图所示：

![链表-链表与数据性能对比](https://code-thinking-1253855093.file.myqcloud.com/pics/20200806195200276.png)

数组在定义的时候，长度就是固定的，如果想改动数组的长度，就需要重新定义一个新的数组。

链表的长度可以是不固定的，并且可以动态增删， 适合数据量不固定，频繁增删，较少查询的场景。



### 203.移除链表元素

#### 题目

[203. 移除链表元素 - 力扣（LeetCode）](https://leetcode.cn/problems/remove-linked-list-elements/)

给你一个链表的头节点 `head` 和一个整数 `val` ，请你删除链表中所有满足 `Node.val == val` 的节点，并返回 **新的头节点** 。

示例1：

```
输入：head = [1,2,6,3,4,5,6], val = 6
输出：[1,2,3,4,5]
```

![img](https://assets.leetcode.com/uploads/2021/03/06/removelinked-list.jpg)

示例2：

```
输入：head = [], val = 1
输出：[]
```

示例3：

```
输入：head = [7,7,7,7], val = 7
输出：[]
```

提示：

- 列表中的节点数目在范围 [0, 10^4^] 内
- 1 <= Node.val <= 50
- 0 <= val <= 50

#### 思路

[视频讲解：203.移除链表元素](https://www.bilibili.com/video/BV18B4y1s7R9/?spm_id_from=333.788&vd_source=ac7136f9d876267a31549d6a76ffd460)

基本思路很简单，即遍历整个链表，当下一个结点的值等于val时，删除该元素。

需要额外考虑头节点的特殊情况：

- 头节点为空

- 头节点需要删除

此处涉及到链表的两种操作方式：

1. 直接使用所给的链表进行操作
2. 设置一个虚拟头节点后进行操作

操作1：

![203_链表删除元素3](https://code-thinking-1253855093.file.myqcloud.com/pics/2021031609544922.png)

移除头节点和移除其他节点的操作不一样，因为移除链表的其他节点时，都是通过前一个节点来移除当前节点，而头结点没有前一个节点。

移除头节点时，只需要将头节点向后移动一位就可以：

![203_链表删除元素4](https://code-thinking-1253855093.file.myqcloud.com/pics/20210316095512470.png)

使用该操作写代码时，需要单独写一段逻辑对头节点进行处理。

操作2：

![203_链表删除元素6](https://code-thinking-1253855093.file.myqcloud.com/pics/20210316095619221.png)

在头节点之前设置一个虚拟头节点，就可以让链表中的所有元素都按统一的方式进行移除了。

最后返回值的时候需要返回dummyNode.next，即新的头节点

#### 题解

[代码随想录：移除链表元素](https://www.programmercarl.com/0203.移除链表元素.html#算法公开课)

不使用虚拟头节点：

```java
/**
 * Definition for singly-linked list.
 * public class ListNode {
 * int val;
 * ListNode next;
 * ListNode() {}
 * ListNode(int val) { this.val = val; }
 * ListNode(int val, ListNode next) { this.val = val; this.next = next; }
 * }
 */
class Solution {
    public ListNode removeElements(ListNode head, int val) {
        //先判断头节点是否需要删除
        //如果需要删除，将头节点后移
        while (head != null && head.val == val) {
            head = head.next;
        }
        //如果头节点为空，直接返回
        if (head == null) {
            return head;
        }
        //指针
        ListNode cur = head;
        //当指针的下一个节点不为空时，进入循环
        while (cur.next != null) {
            if (cur.next.val == val) {
                //删除元素
                cur.next = cur.next.next;
            } else {
                //指针后移
                cur = cur.next;
            }
        }
        return head;
    }
}
```

使用虚拟头节点：

```java
/**
 * Definition for singly-linked list.
 * public class ListNode {
 * int val;
 * ListNode next;
 * ListNode() {}
 * ListNode(int val) { this.val = val; }
 * ListNode(int val, ListNode next) { this.val = val; this.next = next; }
 * }
 */
class Solution {
    public ListNode removeElements(ListNode head, int val) {
        //创建虚拟头节点，指向head
        ListNode dummy = new ListNode();
        dummy.next = head;
        //指针
        ListNode cur = dummy;
        //所有节点统一操作
        while (cur.next != null) {
            if (cur.next.val == val) {
                cur.next = cur.next.next;
            } else {
                cur = cur.next;
            }
        }
        //返回值为虚拟头节点的下一个节点
        head = dummy.next;
        return head;
    }
}
```



### 1111111
