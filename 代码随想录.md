## 数组

### 数组理论基础

**数组是存放在连续内存空间上的相同类型数据的集合。**

数组可以通过下标索引的方式获取到下标对应的数据。

举一个字符数组的例子，如图所示：

![算法通关数组](https://code-thinking.cdn.bcebos.com/pics/%E7%AE%97%E6%B3%95%E9%80%9A%E5%85%B3%E6%95%B0%E7%BB%84.png)



有两点需要注意：

* **数组下标都是从0开始的。**
* **数组内存空间的地址是连续的**

**因为数组在内存空间的地址是连续的，所以在数组中删除或者增添元素的时候，难免要移动其他元素的地址。**

例如删除下标为3的元素，需要对下标为3的元素后面的所有元素都要做移动操作，如图所示：

![算法通关数组1](https://code-thinking.cdn.bcebos.com/pics/%E7%AE%97%E6%B3%95%E9%80%9A%E5%85%B3%E6%95%B0%E7%BB%841.png)

**数组的元素不能删除，只能覆盖。**

### 704.二分搜索

#### 题目

[704. 二分查找 - 力扣（LeetCode）](https://leetcode.cn/problems/binary-search/description/)

给定一个 n 个元素有序的（升序）整型数组 nums 和一个目标值 target  ，写一个函数搜索 nums 中的 target，如果目标值存在返回下标，否则返回 -1。

你可以假设 nums 中的所有元素是不重复的。

实例1：

```
输入: nums = [-1,0,3,5,9,12], target = 9     
输出: 4       
解释: 9 出现在 nums 中并且下标为 4 
```

实例2：

```text
输入: nums = [-1,0,3,5,9,12], target = 2     
输出: -1        
解释: 2 不存在 nums 中因此返回 -1 
```

#### 思路

[二分搜索算法详解-CSDN博客](https://blog.csdn.net/qq_44096670/article/details/111768372)

首先，了解二分搜索法的基本知识：

在一个有序数组中确定某个元素的位置时可以使用二分搜索法。

假设在[begin，end]范围内搜索某个元素 target，mid = （begin + end）/ 2

1. 如果target < mid，在[begin ， mid]范围内再次二分搜索
2. 如果target > mid，在[mid， end]范围内再次二分搜索
3. 如果target == mid ，直接返回 mid

[视频讲解：704. 二分查找](https://www.bilibili.com/video/BV1fA4y1o715)

本题题目的重点是**有序且无重复元素的数组**，满足使用二分搜索法的两个条件，每当看到这两个条件时，就可以考虑使用二分搜索法。

二分搜索的重点是确定边界条件，并且在使用过程中一直坚持区间定义进行操作。

一般有两种区间定义：

1. 左闭右闭，即 [left，right]
2. 左闭右开，即 [left，right)

#### 题解

[代码随想录：二分查找](https://www.programmercarl.com/0704.二分查找.html#算法公开课)

##### 方法一

方法一将区间定义为左闭右闭。

针对左闭右闭的区间，有三点需要注意：

1. 右闭区间，所以`right = nums.length - 1`
2. [left，right]中left与right可以相等，因此使用`while(left<=right)`。
3. if (nums[middle] > target) 情况中，right 要赋值为 middle - 1。因为是右闭区间，下一次进行二分查找时包含右边界，所以需要将右边界设置为nums[middle-1]。

实现代码：

```java
class Solution {
    public int search(int[] nums, int target) {
        int left = 0;
        int right = nums.length - 1;
        int middle = (left + right) / 2;
        while (left <= right) {
            middle = (left + right) / 2;
            if (nums[middle] < target) {
                left = middle + 1;
            } else if (nums[middle] > target) {
                right = middle - 1;
            } else if (nums[middle] == target) {
                return middle;
            }
        }
        return -1;
    }
}
```

- 时间复杂度：O(log n)
- 空间复杂度：O(1)

##### 方法二

方法二将区间定义为左闭右开。

针对左闭右开的区间，有三点需要注意：

1. 右开区间，所以`right = nums.length`
2. [left，right)中left与right不可以相等，因此使用`while(left<right)`。
3. if (nums[middle] > target) 情况中，right 要赋值为 middle。因为是右开区间，下一次进行二分查找时不会包含右边界，所以需要将右边界设置为nums[middle]。

实现代码：

```java
class Solution {
    public int search(int[] nums, int target) {
        int left = 0;
        int right = nums.length;
        int middle = (left + right) / 2;
        while (left < right) {
            middle = (left + right) / 2;
            if (nums[middle] < target) {
                left = middle + 1;
            } else if (nums[middle] > target) {
                right = middle;
            } else if (nums[middle] == target) {
                return middle;
            }
        }
        return -1;
    }
}
```

- 时间复杂度：O(log n)
- 空间复杂度：O(1)

#### 35.搜索插入位置

##### 题目

[35. 搜索插入位置 - 力扣（LeetCode）](https://leetcode.cn/problems/search-insert-position/description/)

给定一个升序数组和一个目标值，在数组中找到目标值，并返回其索引。如果目标值不存在于数组中，返回它将会被按顺序插入的位置。

你可以假设数组中无重复元素。

示例1：

```
输入: nums = [1,3,5,6], target = 5
输出: 2
```

示例2：

```
输入: [1,3,5,6], target = 2
输出: 1
```

示例3：

```
输入: [1,3,5,6], target = 7
输出: 4
```

示例4：

```
输入: [1,3,5,6], target = 0
输出: 0
```

##### 思路

看到题目中的条件是**无重复元素的有序数组**，目的是**查找某个元素**，第一反应使用二分搜索。

针对**“如果目标值不存在于数组中，返回它将会被按顺序插入的位置”**，可以得到有四种插入情况：

<img src="https://code-thinking-1253855093.file.myqcloud.com/pics/20201216232148471.png" alt="35_搜索插入位置3" style="zoom:75%;float:left" />

1. 目标值等于数组中某一个元素
2. 目标值在数组所有元素之前
3. 目标值插入数组中的某个位置
4. 目标值在数组所有元素之后

##### 题解

[代码随想录 ：搜索插入位置](https://programmercarl.com/0035.搜索插入位置.html)

独立解题如下：

```java
class Solution {
    public int searchInsert(int[] nums, int target) {
        //基本的二分查找，此处采用左闭右闭方法
        int left = 0;
        int right = nums.length - 1;
        int middle = (left + right) / 2;
        while (left <= right) {
            middle = (left + right) / 2;
            if (nums[middle] < target) {
                left = middle + 1;
            } else if (nums[middle] > target) {
                right = middle - 1;
            } else if (nums[middle] == target) {
                return middle;
            }
        }
        //判断插入位置，返回不同的值
        if (middle == 0 && nums[middle] > target) {
            return 0;
        } else if (middle == nums.length - 1 && nums[middle] < target) {
            return nums.length;
        } else if (middle == 0 && nums[middle] < target) {
            return 1;
        } else if (middle == nums.length - 1 && nums[middle] > target) {
            return nums.length - 1;
        } else if (nums[middle] > target) {
            return middle;
        } else {
            return middle + 1;
        }
    }
}
```

观看正确题解之后得到：

```java
class Solution {
    public int searchInsert(int[] nums, int target) {
        int left = 0;
        int right = nums.length - 1;
        int middle = (left + right) / 2;
        while (left <= right) {
            middle = (left + right) / 2;
            if (nums[middle] < target) {
                left = middle + 1;
            } else if (nums[middle] > target) {
                right = middle - 1;
            } else if (nums[middle] == target) {
                //1.目标值等于数组中某一个元素
                return middle;
            }
        }
        //2.目标值在数组所有元素之前：left=0,right=-1,返回right+1=0
        //3.目标值插入数组中的某个位置：right=left-1,nums[left]>target,nums[right]<target,返回right+1
        //4.目标值在数组所有元素之后：right=nums.length-1,返回right+1=nums.length
        //三种情况得到相同返回值
        return right + 1;
    }
}
```

总结：针对不同情况时，正确找出相同点并进行归纳。

#### 34.在排序数组中查找元素的第一个和最后一个位置

##### 题目

[34. 在排序数组中查找元素的第一个和最后一个位置 - 力扣（LeetCode）](https://leetcode.cn/problems/find-first-and-last-position-of-element-in-sorted-array/description/)

给定一个按照升序排列的整数数组 nums，和一个目标值 target。找出给定目标值在数组中的开始位置和结束位置。

如果数组中不存在目标值 target，返回 [-1, -1]。

设计并实现时间复杂度为 `O(log n)` 的算法解决此问题。

示例1：

```
输入：nums = [5,7,7,8,8,10], target = 8
输出：[3,4]
```

示例2：

```
输入：nums = [5,7,7,8,8,10], target = 6
输出：[-1,-1]
```

示例3：

```
输入：nums = [], target = 0
输出：[-1,-1]
```

##### 思路

由题目中的**升序排列数组**，可以使用二分法。

个人思路：使用二分法找到一个位于任意位置的target，未找到则返回[-1,-1]，若找到target，则从找到的target位置分别向左右两边延申并判断是否等于target，找到相应的边界，找到后返回[left，right]

问题如下：

1. 第一次提交没有考虑数组下标越界情况，即出现了nums[-1]的情况。
2. 修改之后成功提交，在学习他人题解讨论时发现，如果用例所给数组为被target填满的数组，此时最坏时间复杂度为O(1)，不满足题目要求，虽然第二次提交通过，但仍是错解。



查阅各种题解后，总结思路：使用两次二分查找，先找到第一个等于target的位置，再找最后一个等于target的位置。

##### 题解

[代码随想录：在排序数组中查找元素的第一个和最后一个位置](https://programmercarl.com/0034.在排序数组中查找元素的第一个和最后一个位置.html)

独立错误题解：

```java
class Solution {
    public int[] searchRange(int[] nums, int target) {
        int left = 0;
        int right = nums.length - 1;
        int mid = 0;
        while (left <= right) {
            mid = left + (right - left) / 2;
            if (nums[mid] < target) {
                left = mid + 1;
            } else if (nums[mid] > target) {
                right = mid - 1;
            } else {
                //当搜索到任意target时，向左右两端进行延申，直到下一个元素不等于target。
                //问题：当数组中所有元素都为target时，时间复杂度为O(1)。
                int l = mid;
                int r = mid;
                while (nums[l] == target) {
                    l--;
                    if (l == -1) {
                        break;
                    }
                }
                while (nums[r] == target) {
                    r++;
                    if (r == nums.length) {
                        break;
                    }
                }
                return new int[] { l + 1, r - 1 };
            }
        }
        return new int[] { -1, -1 };
    }
}
```

修改后题解：

```java
class Solution {
    public int[] searchRange(int[] nums, int target) {
        int left = 0;
        int right = nums.length - 1;
        int mid = 0;
        //存放下标
        int first = -1;
        int last = -1;
        //第一次使用二分法，查询第一个target的位置
        while (left <= right) {
            mid = left + (right - left) / 2;
            if (nums[mid] == target) {
                //**重点**：修改右边界，在搜索到的target左方继续搜索target
                right = mid - 1;
                //修改first，即第一个target的下标位置
                first = mid;
            //正常使用二分法过程
            } else if (nums[mid] < target) {
                left = mid + 1;
            } else if (nums[mid] > target) {
                right = mid - 1;
            }
        }
        //重置左右边界，第二次使用二分法，查询最后一个target的位置
        left = 0;
        right = nums.length - 1;
        while (left <= right) {
            mid = left + (right - left) / 2;
            if (nums[mid] == target) {
                //**重点**：修改左边界，在搜索到的target右方继续搜索target
                left = mid + 1;
                //修改last，即最后一个target的下标位置
                last = mid;
            //正常使用二分法过程
            } else if (nums[mid] < target) {
                left = mid + 1;
            } else if (nums[mid] > target) {
                right = mid - 1;
            }
        }
        return new int[] { first, last };
    }
}
```



#### 69.x的平方根

##### 题目

[[69. x 的平方根 - 力扣（LeetCode）](https://leetcode.cn/problems/sqrtx/description/)](https://leetcode.cn/problems/sqrtx/description/)

给一个非负整数 `x` ，计算并返回 `x` 的 **算术平方根** 。

由于返回类型是整数，结果只保留 **整数部分** ，小数部分将被 **舍去 。**

**注意：**不允许使用任何内置指数函数和算符，例如 `pow(x, 0.5)` 或者 `x ** 0.5` 。

示例1：

```
输入：x = 4
输出：2
```

示例2：

```
输入：x = 8
输出：2
解释：8 的算术平方根是 2.82842..., 由于返回类型是整数，小数部分将被舍去。
```

提示：

- 0 <= x <= 2^31^ - 1

##### 思路

因为x平方根的整数部分ans是满足k^2^<=x的最大k，因此可以对k进行二分查找得到答案。

可以将二分查找的左边界设置为0，将右边界粗略地设置为x，在使用二分查找的过程中，不断将middle的平方与x进行大小比较，调整上下界的范围。

##### 题解

独立完成的题解仅能通过较小的x用例，遭遇较大的x用例时无法通过，初步判断为middle的平方超过了int类型的取值范围。

解决方法为将middle的平方类型转换为浮点型。

独立题解如下：

```java
class Solution {
    public int mySqrt(int x) {
        int left = 0;
        int right = x;
        int middle = 0;
        while (left <= right) {
            middle = left + (right - left) / 2;
            //使用强制类型转换
            if ((long) middle * middle < x) {
                left = middle + 1;
            } else if ((long) middle * middle > x) {
                right = middle - 1;
            } else if ((long) middle * middle == x) {
                return middle;
            }
        }
        return right;
    }
}
```

官方题解如下：

```java
class Solution {
    public int mySqrt(int x) {
        //使用ans存储目标值
        int l = 0, r = x, ans = -1;
        while (l <= r) {
            int mid = l + (r - l) / 2;
            if ((long) mid * mid <= x) {
                ans = mid;
                l = mid + 1;
            } else {
                r = mid - 1;
            }
        }
        return ans;
    }
}
```

#### 367.有效的完全平方数

##### 题目

[367. 有效的完全平方数 - 力扣（LeetCode）](https://leetcode.cn/problems/valid-perfect-square/description/)

给一个正整数 `num` 。如果 `num` 是一个完全平方数，则返回 `true` ，否则返回 `false` 。

**完全平方数** 是一个可以写成某个整数的平方的整数。换句话说，它可以写成某个整数和自身的乘积。

不能使用任何内置的库函数，如 `sqrt` 。

示例1：

```
输入：num = 16
输出：true
解释：返回 true ，因为 4 * 4 = 16 且 4 是一个整数。
```

示例2：

```
输入：num = 14
输出：false
解释：返回 false ，因为 3.742 * 3.742 = 14 但 3.742 不是一个整数。
```

提示：

- 0 <= num <= 2^31^ - 1

##### 思路

首先，可以考虑暴力解法，从1开始遍历所有正整数，直到找到满足x^2^=num的正整数，则返回true，如果出现x^2^>num，则返回false。

还可以使用二分法，左边界设置为0，右边界设置为num，持续使用二分法判断middle^2^与num的大小。

由题给出的num的范围，可以得到计算middle^2^的时候，需要使用强制类型转换为浮点型，再与num进行比较。

本人此题使用二分法。

##### 题解

题解如下：

```java
class Solution {
    public boolean isPerfectSquare(int num) {
        int left = 0;
        int right = num;
        int mid = 0;
        while (left <= right) {
            mid = left + (right - left) / 2;
            //得到num为mid的平方，返回true
            if ((long) mid * mid == num) {
                return true;
            } else if ((long) mid * mid > num) {
                right = mid - 1;
            } else {
                left = mid + 1;
            }
        }
        //二分搜索结束都没有找到相应的x，返回false
        return false;
    }
}
```



### 27.移除元素

#### 题目

[27. 移除元素 - 力扣（LeetCode）](https://leetcode.cn/problems/remove-element/description/)

给你一个数组 `nums` 和一个值 `val`，你需要 **原地** 移除所有数值等于 `val` 的元素。元素的顺序可能发生改变。然后返回 `nums` 中与 `val` 不同的元素的数量。

假设 `nums` 中不等于 `val` 的元素数量为 `k`，要通过此题，您需要执行以下操作：

- 更改 `nums` 数组，使 `nums` 的前 `k` 个元素包含不等于 `val` 的元素。`nums` 的其余元素和 `nums` 的大小并不重要。
- 返回 `k`。

示例1：

```
输入：nums = [3,2,2,3], val = 3
输出：2, nums = [2,2,_,_]
解释：你的函数函数应该返回 k = 2, 并且 nums 中的前两个元素均为 2。
你在返回的 k 个元素之外留下了什么并不重要（因此它们并不计入评测）。
```

示例2：

```
输入：nums = [0,1,2,2,3,0,4,2], val = 2
输出：5, nums = [0,1,4,0,3,_,_,_]
解释：你的函数应该返回 k = 5，并且 nums 中的前五个元素为 0,0,1,3,4。
注意这五个元素可以任意顺序返回。
你在返回的 k 个元素之外留下了什么并不重要（因此它们并不计入评测）。
```

#### 思路

[视频讲解：27. 移除元素](https://www.bilibili.com/video/BV12A4y1Z7LP)

重点：数组的元素在内存地址中是连续的，不能单独删除数组中的某个元素，只能对元素进行覆盖。

看到题目第一眼想到暴力解法：使用嵌套for循环，第一个for循环遍历数组元素，第二个for循环更新数组。

暴力解法时间复杂度为O(n^2^)，删除过程如下：

![27.移除元素-暴力解法](https://code-thinking.cdn.bcebos.com/gifs/27.%E7%A7%BB%E9%99%A4%E5%85%83%E7%B4%A0-%E6%9A%B4%E5%8A%9B%E8%A7%A3%E6%B3%95.gif)

[一文看懂快慢指针-CSDN博客](https://blog.csdn.net/softpoeter/article/details/103153564)

快慢指针法：通过一个快指针和一个慢指针在一个for循环下完成两个for循环的工作。

定义快慢指针如下：

- 快指针：寻找新数组中的元素，即与目标值不相等的元素。
- 慢指针：指向更新新数组下标的位置。

时间复杂度为O(n)，过程如下：

![27.移除元素-双指针法](https://code-thinking.cdn.bcebos.com/gifs/27.%E7%A7%BB%E9%99%A4%E5%85%83%E7%B4%A0-%E5%8F%8C%E6%8C%87%E9%92%88%E6%B3%95.gif)

#### 题解

[代码随想录：移除元素](https://www.programmercarl.com/0027.移除元素.html#思路)

快慢指针法：

```java
class Solution {
    public int removeElement(int[] nums, int val) {
        int slow = 0;
        for (int fast = 0; fast < nums.length; fast++) {
            if (nums[fast] != val) {
                nums[slow] = nums[fast];
                slow++;
            }
        }
        return slow;
    }
}
```

暴力解法：

```java
class Solution {
    public int removeElement(int[] nums, int val) {
        //size为新数组的长度
        int size = nums.length;
        for (int i = 0; i < size; i++) {
            if (nums[i] == val) {
                for (int j = i + 1; j < size; j++) {
                    nums[j - 1] = nums[j];
                }
                //每去除一个元素，下标i之后的元素都向前移动一位，因此i也需要向前移动一位。
                i--;
                //每去除一个元素，新数组长度减一。
                size--;
            }
        }
        return size;
    }
}
```

#### 283.移动零

##### 题目

[283. 移动零 - 力扣（LeetCode）](https://leetcode.cn/problems/move-zeroes/description/)

给定一个数组 `nums`，编写一个函数将所有 `0` 移动到数组的末尾，同时保持非零元素的相对顺序。

**请注意** ，必须在不复制数组的情况下原地对数组进行操作。

示例1：

```
输入: nums = [0,1,0,3,12]
输出: [1,3,12,0,0]
```

示例2：

```
输入: nums = [0]
输出: [0]
```

##### 思路

[代码随想录：移动零](https://www.programmercarl.com/0283.移动零.html)

首先可以使用暴力解法：两层for循环，模拟删除数组元素的过程。

其次，可以想到使用快慢指针法，类似于移除元素0，唯一的区别是移除完之后将慢指针之后的元素都赋值为0。

##### 题解

独立题解：

```java
class Solution {
    public void moveZeroes(int[] nums) {
        int slow = 0;
        for (int fast = 0; fast < nums.length; fast++) {
            if (nums[fast] != 0) {
                nums[slow] = nums[fast];
                slow++;
            }
        }
        //将慢指针后的元素赋值为0
        for (int i = slow; i < nums.length; i++) {
            nums[i] = 0;
        }
    }
}
```

改为一次遍历：

```java
class Solution {
    public void moveZeroes(int[] nums) {
        int slow = 0;
        for (int fast = 0; fast < nums.length; fast++) {
            if (nums[fast] != 0) {
                //直接交换快指针与慢指针元素的位置，可以将0交换到数组末尾。
                int tmp = nums[slow];
                nums[slow] = nums[fast];
                nums[fast] = tmp;
                slow++;
            }
        }
    }
}
```

#### 26.删除有序数组中的重复项

##### 题目

给你一个 **非严格递增排列** 的数组`nums`，请你**原地**删除重复出现的元素，使每个元素**只出现一次**，返回删除后数组的新长度。元素的**相对顺序**应该保持 **一致** 。然后返回`nums`中唯一元素的个数。

考虑`nums`的唯一元素的数量为`k`，你需要做以下事情确保你的题解可以被通过：

- 更改数组`nums`，使`nums`的前`k`个元素包含唯一元素，并按照它们最初在`nums`中出现的顺序排列。`nums`的其余元素与`nums`的大小不重要。
- 返回`k`。

示例1：

```
输入：nums = [1,1,2]
输出：2, nums = [1,2,_]
解释：函数应该返回新的长度 2 ，并且原数组 nums 的前两个元素被修改为 1, 2 。不需要考虑数组中超出新长度后面的元素。
```

示例2：

```
输入：nums = [0,0,1,1,1,2,2,3,3,4]
输出：5, nums = [0,1,2,3,4]
解释：函数应该返回新的长度 5 ， 并且原数组 nums 的前五个元素被修改为 0, 1, 2, 3, 4 。不需要考虑数组中超出新长度后面的元素。
```

##### 思路

由题**有序数组**，可得重复元素一定相邻。

要删除重复元素，实质是将不重复的元素都移到数组左侧。

可以使用双指针法，分别定义快慢指针fast和slow。

比较fast和slow大小：

- 如果相等，fast向后移动一位
- 如果不相等，将fast上的元素赋值到slow+1上，slow和fast都向后移动一位

<img src="https://pic.leetcode-cn.com/1631552114-iGjdpt-%E5%BF%AB%E6%85%A2%E6%8C%87%E9%92%88.png" alt="快慢指针.png" style="zoom: 50%;" />

##### 题解

```java
class Solution {
    public int removeDuplicates(int[] nums) {
        int slow = 0;
        int fast = 0;
        //新数组长度
        int k = 1;
        for (fast = 0; fast < nums.length; fast++) {
            if (nums[fast] != nums[slow]) {
                k++;
                slow++;
                nums[slow] = nums[fast];
            }
        }
        return k;
    }
}
```



### 977.有序数组的平方

#### 题目

[977. 有序数组的平方 - 力扣（LeetCode）](https://leetcode.cn/problems/squares-of-a-sorted-array/description/)

给你一个按 **非递减顺序** 排序的整数数组 `nums`，返回 **每个数字的平方** 组成的新数组，要求也按 **非递减顺序** 排序。

示例1：

```
输入：nums = [-4,-1,0,3,10]
输出：[0,1,9,16,100]
解释：平方后，数组变为 [16,1,0,9,100]
排序后，数组变为 [0,1,9,16,100]
```

示例2：

```
输入：nums = [-7,-3,2,3,11]
输出：[4,9,9,49,121]
```

#### 思路

[视频讲解：977.有序数组的平方](https://www.bilibili.com/video/BV1QB4y1D7ep)

第一眼依然是最直观的暴力解法：先将所有元素平方，再进行排序。

暴力解法虽然直观，但是时间复杂度较高，为O(n+nlogn)。

由题目得到**非递减数组**，且**包含负数**，可以得到平方值最大的元素一定在数组两端，而不是在数组中间，此时可以考虑使用双指针法。

左指针指向起始位置，右指针指向终止位置。

定义一个相同大小的新数组result用于存放排序后的元素。

因为要求**非递减顺序排列**，创建指针k指向新数组的终止位置，每次添加新元素后指针向前移动一位。

过程如下：

![img](https://code-thinking.cdn.bcebos.com/gifs/977.%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%E7%9A%84%E5%B9%B3%E6%96%B9.gif)

#### 题解

[代码随想录 ：有序数组的平方](https://www.programmercarl.com/0977.有序数组的平方.html)

双指针法：

```java
class Solution {
    public int[] sortedSquares(int[] nums) {
        int[] result = new int[nums.length];
        int left = 0;
        int right = nums.length - 1;
        int k = nums.length - 1;
        while (left <= right) {
            //比较平方值大小，将较大值添加到新数组中，同时根据不同情况移动left或right指针
            if (nums[left] * nums[left] >= nums[right] * nums[right]) {
                result[k--] = nums[left] * nums[left];
                left++;
            } else {
                result[k--] = nums[right] * nums[right];
                right--;
            }
        }
        return result;
    }
}
```

暴力解法：

```java
class Solution {
    public int[] sortedSquares(int[] nums) {
        int[] ans = new int[nums.length];
        for (int i = 0; i < nums.length; ++i) {
            ans[i] = nums[i] * nums[i];
        }
        Arrays.sort(ans);
        return ans;
    }
}
```

### 209.长度最小的子数组

#### 题目

[209. 长度最小的子数组 - 力扣（LeetCode）](https://leetcode.cn/problems/minimum-size-subarray-sum/description/)

给定一个含有 `n` 个正整数的数组和一个正整数 `target` **。**

找出该数组中满足其总和大于等于 `target` 的长度最小的 子数组`[numsl, numsl+1, ..., numsr-1, numsr]` ，并返回其长度**。**如果不存在符合条件的子数组，返回 `0` 。

示例1：

```
输入：target = 7, nums = [2,3,1,2,4,3]
输出：2
解释：子数组 [4,3] 是该条件下的长度最小的子数组。
```

示例2：

```
输入：target = 4, nums = [1,4,4]
输出：1
```

示例3：

```
输入：target = 11, nums = [1,1,1,1,1,1,1,1]
输出：0
```

#### 思路

[视频讲解：209.长度最小的子数组](https://www.bilibili.com/video/BV1tZ4y1q7XE)

暴力解法：使用两个for循环，一个for循环起始位置，另一个循环终止位置，不断寻找符合条件的子序列，时间复杂度O(n^2^)。

[滑动窗口法总结_滑窗法-CSDN博客](https://blog.csdn.net/Dby_freedom/article/details/89066140)

滑动窗口，即**不断调节子序列的起始位置和终止位置**，从而得到所需要的结果。

只使用一个for循环，该循环的索引表示子序列的终止位置，查找过程如下：

![209.长度最小的子数组](https://code-thinking.cdn.bcebos.com/gifs/209.%E9%95%BF%E5%BA%A6%E6%9C%80%E5%B0%8F%E7%9A%84%E5%AD%90%E6%95%B0%E7%BB%84.gif)

由过程演示发现滑动窗口可以理解为双指针法的一种。

在本题中实现滑动窗口，要确定如下三点：

1. 窗口内是什么？
2. 如何移动窗口的起始位置？
3. 如何移动窗口的终止位置？

理解：

1. 窗口是满足sum>=target的长度最小的子序列。
2. 当前窗口满足sum>=target时，向右移动起始位置（即缩小窗口）。
3. 窗口的终止位置即遍历数组的指针，也就是for循环中的索引。

解题关键在于起始位置的移动，如图：

<img src="https://code-thinking-1253855093.file.myqcloud.com/pics/20210312160441942.png" alt="leetcode_209" style="zoom:80%;" />

滑动窗口的精妙之处在于**根据当前子序列和大小的情况，不断调节子序列的起始位置**。

时间复杂度从暴力解法的O(n^2^)降为O(n)。

#### 题解

[代码随想录：长度最小的子数组](https://www.programmercarl.com/0209.长度最小的子数组.html#思路)

滑动窗口：

```java
class Solution {
    public int minSubArrayLen(int target, int[] nums) {
        int start = 0;
        int end = 0;
        //ans设置为大于数组长度的数字，用来与子序列长度作比较
        //也可以设置为Integer.MAX_VALUE
        int ans = nums.length + 1;
        int sum = 0;
        for (end = 0; end < nums.length; end++) {
            //根据end的移动，向sum中加元素
            sum += nums[end];
            //当sum>=target时，移动start位置
            //注意要使用while循环，因为有可能需要多次移动start位置
            while (sum >= target) {
                //获取ans与新子序列长度的较小值
                ans = Math.min(ans, end - start + 1);
                sum -= nums[start++];
            }
        }
        //判断ans是否改变，即是否存在符合条件的子序列
        return ans == nums.length + 1 ? 0 : ans;
    }
}
```

暴力解法：

```java
class Solution {
    public int minSubArrayLen(int s, int[] nums) {
        int n = nums.length;
        if (n == 0) {
            return 0;
        }
        int ans = Integer.MAX_VALUE;
        //两层for循环
        for (int i = 0; i < n; i++) {
            int sum = 0;
            for (int j = i; j < n; j++) {
                sum += nums[j];
                if (sum >= s) {
                    ans = Math.min(ans, j - i + 1);
                    break;
                }
            }
        }
        return ans == Integer.MAX_VALUE ? 0 : ans;
    }
}
```

#### 904.水果成篮

##### 题目

[904. 水果成篮 - 力扣（LeetCode）](https://leetcode.cn/problems/fruit-into-baskets/description/)

你正在探访一家农场，农场从左到右种植了一排果树。这些树用一个整数数组 `fruits` 表示，其中 `fruits[i]` 是第 `i` 棵树上的水果 **种类** 。

你想要尽可能多地收集水果。然而，农场的主人设定了一些严格的规矩，你必须按照要求采摘水果：

- 你只有 **两个** 篮子，并且每个篮子只能装 **单一类型** 的水果。每个篮子能够装的水果总量没有限制。
- 你可以选择任意一棵树开始采摘，你必须从 **每棵** 树（包括开始采摘的树）上 **恰好摘一个水果** 。采摘的水果应当符合篮子中的水果类型。每采摘一次，你将会向右移动到下一棵树，并继续采摘。
- 一旦你走到某棵树前，但水果不符合篮子的水果类型，那么就必须停止采摘。

给你一个整数数组 `fruits` ，返回你可以收集的水果的 **最大** 数目。

示例1：

```
输入：fruits = [1,2,1]
输出：3
解释：可以采摘全部 3 棵树。
```

示例2：

```
输入：fruits = [0,1,2,2]
输出：3
解释：可以采摘 [1,2,2] 这三棵树。
如果从第一棵树开始采摘，则只能采摘 [0,1] 这两棵树。
```

示例3：

```
输入：fruits = [1,2,3,2,2]
输出：4
解释：可以采摘 [2,3,2,2] 这四棵树。
如果从第一棵树开始采摘，则只能采摘 [1,2] 这两棵树。
```

示例4：

```
输入：fruits = [3,3,3,1,2,1,1,2,3,3,4]
输出：5
解释：可以采摘 [1,2,1,1,2] 这五棵树。
```

提示：

- `1 <= fruits.length <= 105`
- `0 <= fruits[i] < fruits.length`

##### 思路

理解题意：从任意位置开始，**同时使用**两个篮子采集水果，一旦选择后不能修改篮子所装的水果种类，当所有树处理完或遇到第一棵种类不同的树则停止。

初见思路：使用滑动窗口，定义快慢指针，再定义一个数组存放篮子中的水果类型，当快指针遇到不在篮子中的水果类型时，将**慢指针所在位置的水果**替换为**快指针所在位置的水果**，再向右逐个移动慢指针，移动条件为**慢指针水果类型不在篮子中**。

遇到的问题：输入条件为[3,3,3,1,2,1,1,2,3,3,4]时，当子序列[1,2,1,1,2,3]时，慢指针移动后子序列会变成[2,1,1,2,3]。

改进思路：直接将慢指针移动到快指针左侧一格，再从右往左移动，判断条件为**左侧一格水果**是否与**慢指针当前位置水果**相同。

原理：因为篮子中只有两种水果，**快指针所在位置的水果**在子序列中一定只出现那一次，而另一个篮子里的水果一定位于**快指针左侧一格**，如果子序列长度不止为2，左侧的水果一定与**快指针左侧一格**相等。



查阅力扣题解：

1. 创建一个水果数组，下标代表水果种类，元素表示水果在篮子中的数量。
2. 快指针移动时，新水果数量++。
3. 判断新位置的水果之前是否在篮子里，若不在则种类数++。
4. 当种类数>2时进入循环，慢指针移动，且旧水果数量--。
5. 判断旧位置的水果是否还在篮子里，若不在则种类数--，若在则继续循环。
6. Max

##### 题解

错误题解：

```java
class Solution {
    public int totalFruit(int[] fruits) {
        int left = 0;
        int right = 0;
        int ans = 0;
        int[] type = new int[2];
        type[0] = fruits[0];
        type[1] = -1;
        for(right = 0; right<fruits.length; right++){
            if(type[1]==-1&&fruits[right]!=type[0]){
                type[1] = fruits[right];
            }
            if(fruits[right]!=type[0]&&fruits[right]!=type[1]){
                type[0] = fruits[right-1];
                type[1] = fruits[right];
                //错误点
                while(fruits[left]!=type[0]&&fruits[left]!=type[1]){
                    left++;
                }
            }
            ans=Math.max(ans,right - left +1);
        }
        return ans;
    }
}
```

独立正确题解：

```java
class Solution {
    public int totalFruit(int[] fruits) {
        //快慢指针
        int left = 0;
        int right = 0;
        //答案值
        int ans = 0;
        //存放水果种类
        int[] type = new int[2];
        //设置第一个篮子放第一棵树的水果
        type[0] = fruits[0];
        //设置第二个篮子暂时不放水果
        type[1] = -1;
        //快指针先移动
        for (right = 0; right < fruits.length; right++) {
            //首次遇到与第一棵树不同的水果类型，将其放入第二个篮子中
            if (type[1] == -1 && fruits[right] != type[0]) {
                type[1] = fruits[right];
            }
            if (fruits[right] != type[0] && fruits[right] != type[1]) {
                //遇到不在篮子中的水果类型时，替换水果类型
                type[0] = fruits[right - 1];
                type[1] = fruits[right];
                //将慢指针移到到快指针左侧
                left = right - 1;
                //判断更换水果类型后，慢指针所在的位置
                while (fruits[left - 1] == fruits[left]) {
                    left--;
                }
            }
            //通过比较得到最大子序列
            ans = Math.max(ans, right - left + 1);
        }
        return ans;
    }
}
```

力扣题解1：

```java
 class Solution {
    public int totalFruit(int[] fruits) {
        // 返回值
        int totol = 0; 
        // 滑动条件：窗口内的种类数
        int cate = 0;  
        // 各种水果的计数
        int[] nums = new int[fruits.length+10];
        for(int left=0,right=0; right < fruits.length; right++){
            //  右累加
            if(++nums[ fruits[right] ] == 1) 
                cate++; //  计数累加 + 新品种类++
            //  左滑动
            while(cate>2){
                if(--nums[ fruits[left++] ] == 0) 
                    cate--;//  计数减少 + 减空的种类--
            }
            //  通过比较获取较大值
            totol = Math.max(totol, right-left+1);
        }
        return totol;
    }
}
```

力扣解题2（哈希表）：

```java
class Solution {
    public int totalFruit(int[] fruits) {
        int n = fruits.length;
        Map<Integer, Integer> cnt = new HashMap<Integer, Integer>();

        int left = 0, ans = 0;
        for (int right = 0; right < n; ++right) {
            cnt.put(fruits[right], cnt.getOrDefault(fruits[right], 0) + 1);
            while (cnt.size() > 2) {
                cnt.put(fruits[left], cnt.get(fruits[left]) - 1);
                if (cnt.get(fruits[left]) == 0) {
                    cnt.remove(fruits[left]);
                }
                ++left;
            }
            ans = Math.max(ans, right - left + 1);
        }
        return ans;
    }
}
```



### 59.螺旋矩阵Ⅱ

#### 题目

[59. 螺旋矩阵 II - 力扣（LeetCode）](https://leetcode.cn/problems/spiral-matrix-ii/)

给你一个正整数 n ，生成一个包含 1 到 n^2^ 所有元素，且元素按顺时针顺序螺旋排列的 n x n 正方形矩阵 matrix 。

示例1：

<img src="https://assets.leetcode.com/uploads/2020/11/13/spiraln.jpg" alt="img" style="zoom: 67%;float:left" />

```
输入：n = 3
输出：[[1,2,3],[8,9,4],[7,6,5]]
```

示例2：

```
输入：n = 1
输出：[[1]]
```

#### 思路

模拟顺时针画矩阵的过程:

- 从左到右填充上行
- 从上到下填充右列
- 从右到左填充下行
- 从下到上填充左列

由外向内一圈一圈填充。

按照左闭右开的原则进行填充：

<img src="https://code-thinking-1253855093.file.myqcloud.com/pics/20220922102236.png" alt="img" style="zoom: 40%;" />



#### 题解

```java
class Solution {
    public int[][] generateMatrix(int n) {
        int[][] matrix = new int[n][n];
        //定义每一圈的起始位置
        int startX = 0,startY = 0;
        //用于控制每一次遍历边的长度
        int offset = 1;
        //填写的数字
        int num = 1;
        //行列数
        int i = 0, j = 0;
        while (num < n * n) {
            //确定起始点
            i = startX;
            j = startY;
            //上行从左往右
            for (; j < n - offset; j++) {
                matrix[i][j] = num++;
            }
            //右列从上往下
            for (; i < n - offset; i++) {
                matrix[i][j] = num++;
            }
            //下行从右往左
            for (; j > startY; j--) {
                matrix[i][j] = num++;
            }
            //左列从下往上
            for (; i > startX; i--) {
                matrix[i][j] = num++;
            }
            //下一次遍历边的长度减小
            offset++;
            //起始位置改变
            startX++;
            startY++;
        }
        //当n为奇数时，需要单独给最中间的一格赋值
        if (n % 2 == 1) {
            matrix[n / 2][n / 2] = n * n;
        }
        return matrix;
    }
}
```



## 链表

### 链表理论基础

#### 链表基础

链表是一种通过指针串联在一起的线性结构，每一个节点由两部分组成，分别是数据域和指针域（存放指向下一个节点的指针），最后一个节点的指针域指向null（空指针的意思）。

链表的入口节点称为链表的头结点也就是head。

如图所示：

![链表1](https://code-thinking-1253855093.file.myqcloud.com/pics/20200806194529815.png)

#### 链表类型

##### 单链表

上面介绍的就是单链表

##### 双链表	

单链表中的指针域只能指向节点的下一个节点。

双链表：每一个节点有两个指针域，一个指向下一个节点，一个指向上一个节点。

双链表既可以向前查询也可以向后查询。

如图所示：

![链表2](https://code-thinking-1253855093.file.myqcloud.com/pics/20200806194559317.png)

##### 循环链表

循环链表，顾名思义，就是链表首尾相连。

循环链表可以用来解决约瑟夫环问题。

![链表4](https://code-thinking-1253855093.file.myqcloud.com/pics/20200806194629603.png)

#### 存储方式

数组是在内存中是连续分布的，但是链表在内存中可不是连续分布的。

链表是通过指针域的指针链接在内存中各个节点。

所以链表中的节点在内存中不是连续分布的 ，而是散乱分布在内存中的某地址上，分配机制取决于操作系统的内存管理。

如图所示：

![链表3](https://code-thinking-1253855093.file.myqcloud.com/pics/20200806194613920.png)

这个链表起始节点为2， 终止节点为7， 各个节点分布在内存的不同地址空间上，通过指针串联在一起。

#### 链表的定义

```java
public class ListNode {
    // 结点的值
    int val;

    // 下一个结点
    ListNode next;

    // 节点的构造函数(无参)
    public ListNode() {
    }

    // 节点的构造函数(有一个参数)
    public ListNode(int val) {
        this.val = val;
    }

    // 节点的构造函数(有两个参数)
    public ListNode(int val, ListNode next) {
        this.val = val;
        this.next = next;
    }
}
```

#### 链表的操作

##### 删除节点

删除D节点，如图所示：

![链表-删除节点](https://code-thinking-1253855093.file.myqcloud.com/pics/20200806195114541-20230310121459257.png)

将C节点的next指针指向E节点即可。

Java有自己的内存回收机制，不需要手动释放D节点的内存。

##### 添加节点

如图所示：

![链表-添加节点](https://code-thinking-1253855093.file.myqcloud.com/pics/20200806195134331-20230310121503147.png)

可以看出链表的增添和删除都是O(1)操作，也不会影响到其他节点。

注意：如果删除的是第五个节点，需要从头节点查找到第四个节点通过next指针进行删除操作，查找的时间复杂度是O(n)。

#### 性能分析

表的特性和数组的特性进行一个对比，如图所示：

![链表-链表与数据性能对比](https://code-thinking-1253855093.file.myqcloud.com/pics/20200806195200276.png)

数组在定义的时候，长度就是固定的，如果想改动数组的长度，就需要重新定义一个新的数组。

链表的长度可以是不固定的，并且可以动态增删， 适合数据量不固定，频繁增删，较少查询的场景。



### 203.移除链表元素

#### 题目

[203. 移除链表元素 - 力扣（LeetCode）](https://leetcode.cn/problems/remove-linked-list-elements/)

给你一个链表的头节点 `head` 和一个整数 `val` ，请你删除链表中所有满足 `Node.val == val` 的节点，并返回 **新的头节点** 。

示例1：

```
输入：head = [1,2,6,3,4,5,6], val = 6
输出：[1,2,3,4,5]
```

![img](https://assets.leetcode.com/uploads/2021/03/06/removelinked-list.jpg)

示例2：

```
输入：head = [], val = 1
输出：[]
```

示例3：

```
输入：head = [7,7,7,7], val = 7
输出：[]
```

提示：

- 列表中的节点数目在范围 [0, 10^4^] 内
- 1 <= Node.val <= 50
- 0 <= val <= 50

#### 思路

[视频讲解：203.移除链表元素](https://www.bilibili.com/video/BV18B4y1s7R9/?spm_id_from=333.788&vd_source=ac7136f9d876267a31549d6a76ffd460)

基本思路很简单，即遍历整个链表，当下一个结点的值等于val时，删除该元素。

需要额外考虑头节点的特殊情况：

- 头节点为空

- 头节点需要删除

此处涉及到链表的两种操作方式：

1. 直接使用所给的链表进行操作
2. 设置一个虚拟头节点后进行操作

操作1：

![203_链表删除元素3](https://code-thinking-1253855093.file.myqcloud.com/pics/2021031609544922.png)

移除头节点和移除其他节点的操作不一样，因为移除链表的其他节点时，都是通过前一个节点来移除当前节点，而头结点没有前一个节点。

移除头节点时，只需要将头节点向后移动一位就可以：

![203_链表删除元素4](https://code-thinking-1253855093.file.myqcloud.com/pics/20210316095512470.png)

使用该操作写代码时，需要单独写一段逻辑对头节点进行处理。

操作2：

![203_链表删除元素6](https://code-thinking-1253855093.file.myqcloud.com/pics/20210316095619221.png)

在头节点之前设置一个虚拟头节点，就可以让链表中的所有元素都按统一的方式进行移除了。

最后返回值的时候需要返回dummyNode.next，即新的头节点

#### 题解

[代码随想录：移除链表元素](https://www.programmercarl.com/0203.移除链表元素.html#算法公开课)

不使用虚拟头节点：

```java
/**
 * Definition for singly-linked list.
 * public class ListNode {
 * int val;
 * ListNode next;
 * ListNode() {}
 * ListNode(int val) { this.val = val; }
 * ListNode(int val, ListNode next) { this.val = val; this.next = next; }
 * }
 */
class Solution {
    public ListNode removeElements(ListNode head, int val) {
        //先判断头节点是否需要删除
        //如果需要删除，将头节点后移
        while (head != null && head.val == val) {
            head = head.next;
        }
        //如果头节点为空，直接返回
        if (head == null) {
            return head;
        }
        //指针
        ListNode cur = head;
        //当指针的下一个节点不为空时，进入循环
        while (cur.next != null) {
            if (cur.next.val == val) {
                //删除元素
                cur.next = cur.next.next;
            } else {
                //指针后移
                cur = cur.next;
            }
        }
        return head;
    }
}
```

使用虚拟头节点：

```java
/**
 * Definition for singly-linked list.
 * public class ListNode {
 * int val;
 * ListNode next;
 * ListNode() {}
 * ListNode(int val) { this.val = val; }
 * ListNode(int val, ListNode next) { this.val = val; this.next = next; }
 * }
 */
class Solution {
    public ListNode removeElements(ListNode head, int val) {
        //创建虚拟头节点，指向head
        ListNode dummy = new ListNode();
        dummy.next = head;
        //指针
        ListNode cur = dummy;
        //所有节点统一操作
        while (cur.next != null) {
            if (cur.next.val == val) {
                cur.next = cur.next.next;
            } else {
                cur = cur.next;
            }
        }
        //返回值为虚拟头节点的下一个节点
        head = dummy.next;
        return head;
    }
}
```



### 707.设计链表

#### 题目

[707. 设计链表 - 力扣（LeetCode）](https://leetcode.cn/problems/design-linked-list/description/)

你可以选择使用单链表或者双链表，设计并实现自己的链表。

单链表中的节点应该具备两个属性：`val` 和 `next` 。`val` 是当前节点的值，`next` 是指向下一个节点的指针/引用。

如果是双向链表，则还需要属性 `prev` 以指示链表中的上一个节点。假设链表中的所有节点下标从 **0** 开始。

实现 `MyLinkedList` 类：

- `MyLinkedList()` 初始化 `MyLinkedList` 对象。
- `int get(int index)` 获取链表中下标为 `index` 的节点的值。如果下标无效，则返回 `-1` 。
- `void addAtHead(int val)` 将一个值为 `val` 的节点插入到链表中第一个元素之前。在插入完成后，新节点会成为链表的第一个节点。
- `void addAtTail(int val)` 将一个值为 `val` 的节点追加到链表中作为链表的最后一个元素。
- `void addAtIndex(int index, int val)` 将一个值为 `val` 的节点插入到链表中下标为 `index` 的节点之前。如果 `index` 等于链表的长度，那么该节点会被追加到链表的末尾。如果 `index` 比长度更大，该节点将 **不会插入** 到链表中。
- `void deleteAtIndex(int index)` 如果下标有效，则删除链表中下标为 `index` 的节点。

示例：

```
输入
["MyLinkedList", "addAtHead", "addAtTail", "addAtIndex", "get", "deleteAtIndex", "get"]
[[], [1], [3], [1, 2], [1], [1], [1]]
输出
[null, null, null, null, 2, null, 3]

解释
MyLinkedList myLinkedList = new MyLinkedList();
myLinkedList.addAtHead(1);
myLinkedList.addAtTail(3);
myLinkedList.addAtIndex(1, 2);    // 链表变为 1->2->3
myLinkedList.get(1);              // 返回 2
myLinkedList.deleteAtIndex(1);    // 现在，链表变为 1->3
myLinkedList.get(1);              // 返回 3
```

代码模板：

```java
class MyLinkedList {

    public MyLinkedList() {

    }
    
    public int get(int index) {

    }
    
    public void addAtHead(int val) {

    }
    
    public void addAtTail(int val) {

    }
    
    public void addAtIndex(int index, int val) {

    }
    
    public void deleteAtIndex(int index) {

    }
}

/**
 * Your MyLinkedList object will be instantiated and called as such:
 * MyLinkedList obj = new MyLinkedList();
 * int param_1 = obj.get(index);
 * obj.addAtHead(val);
 * obj.addAtTail(val);
 * obj.addAtIndex(index,val);
 * obj.deleteAtIndex(index);
 */
```

#### 思路

[视频讲解：707.设计链表](https://www.bilibili.com/video/BV1FU4y1X7WD)

使用虚拟头节点设计单向链表。

1. 设计Node类，类中有属性val和next，同时设计构造方法
2. 链表类中设计两个属性：有效节点数size以及虚拟头节点dummyHead
3. MyLinkedList()：构造方法，设置size=0和dummyHead
4. get(int index)：首先判断下标是否有效，下标无效返回-1，创建指针cur，根据index将指针向链表尾端移动，移动到index位置后返回cur.val
5. addAtHead(int val)：通过虚拟头节点直接添加，注意要size++
6. addAtTail(int val)：先将指针移动到尾端，再添加元素，注意size++
7. addAtIndex(int index, int val)：先判断下标是否有效，再将指针移动到index前一个元素位置，再添加元素，注意size++
8. deleteAtIndex(int index)：先判断下标是否有效，再将指针cur移动到index前一个元素位置，使用cur.next = cur.next.next删除元素，注意size--

#### 题解

[代码随想录：设计链表](https://www.programmercarl.com/0707.设计链表.html#算法公开课)

独立题解：

```java
//设计节点类
class Node {
    int val;
    Node next;

    Node(int val) {
        this.val = val;
    }
}

class MyLinkedList {
    int size;
    Node dummyHead;

    public MyLinkedList() {
        size = 0;
        dummyHead = new Node(0);
    }

    public int get(int index) {
        if (index < 0 || index > size - 1) {
            return -1;
        }
        Node cur = dummyHead;
        //可以使用for循环
        while (index >= 0 && index < size) {
            cur = cur.next;
            index--;
        }
        return cur.val;
    }

    public void addAtHead(int val) {
        Node newNode = new Node(val);
        newNode.next = dummyHead.next;
        dummyHead.next = newNode;
        size++;
    }

    public void addAtTail(int val) {
        Node cur = dummyHead;
        while (cur.next != null) {
            cur = cur.next;
        }
        Node newNode = new Node(val);
        cur.next = newNode;
        size++;
    }

    public void addAtIndex(int index, int val) {
        if (index < 0 || index > size) {
            return;
        }
        Node cur = dummyHead;
        //可以使用for循环
        while (index > 0 && index <= size) {
            cur = cur.next;
            index--;
        }
        Node newNode = new Node(val);
        newNode.next = cur.next;
        cur.next = newNode;
        size++;
    }

    public void deleteAtIndex(int index) {
        if (index < 0 || index > size - 1) {
            return;
        }
        Node cur = dummyHead;
        //可以使用for循环
        while (index > 0 && index < size) {
            cur = cur.next;
            index--;
        }
        cur.next = cur.next.next;
        size--;
    }
}

/**
 * Your MyLinkedList object will be instantiated and called as such:
 * MyLinkedList obj = new MyLinkedList();
 * int param_1 = obj.get(index);
 * obj.addAtHead(val);
 * obj.addAtTail(val);
 * obj.addAtIndex(index,val);
 * obj.deleteAtIndex(index);
 */
```



### 206.反转链表

#### 题目

[206. 反转链表 - 力扣（LeetCode）](https://leetcode.cn/problems/reverse-linked-list/description/)

给你单链表的头节点 `head` ，请你反转链表，并返回反转后的链表。

示例1：

![img](https://assets.leetcode.com/uploads/2021/02/19/rev1ex1.jpg)

```
输入：head = [1,2,3,4,5]
输出：[5,4,3,2,1]
```

示例2：

![img](https://assets.leetcode.com/uploads/2021/02/19/rev1ex2.jpg)

```
输入：head = [1,2]
输出：[2,1]
```

示例3：

```
输入：head = []
输出：[]
```



#### 思路

[视频讲解：206.反转链表](https://www.bilibili.com/video/BV1nB4y1i7eL/?spm_id_from=333.788&vd_source=ac7136f9d876267a31549d6a76ffd460)

移动过程如图（图中pre和cur移动顺序有误）：

![img](https://code-thinking.cdn.bcebos.com/gifs/206.%E7%BF%BB%E8%BD%AC%E9%93%BE%E8%A1%A8.gif)

双指针法：

首先定义一个cur指针，指向头节点，再定义一个pre指针，初始化为null。

然后开始反转,为了防止反转后找不到原来的cur.next，需要先用tmp指针保存 cur.next 节点。

然后继续移动pre和cur指针。

最后，cur 指针指向null时，循环结束，链表反转完毕。 此时pre指针指向新的头节点，return pre即可。



递归法：

与双指针法逻辑相同，同样是当cur为空的时候循环结束，不断将cur指向pre的过程。



从后向前递归：

![递归.gif](https://pic.leetcode-cn.com/dacd1bf55dec5c8b38d0904f26e472e2024fc8bee4ea46e3aa676f340ba1eb9d-%E9%80%92%E5%BD%92.gif)

#### 题解

[代码随想录：反转链表](https://www.programmercarl.com/0206.翻转链表.html)

双指针法：

```java
/**
 * Definition for singly-linked list.
 * public class ListNode {
 * int val;
 * ListNode next;
 * ListNode() {}
 * ListNode(int val) { this.val = val; }
 * ListNode(int val, ListNode next) { this.val = val; this.next = next; }
 * }
 */
class Solution {
    public ListNode reverseList(ListNode head) {
        //cur为当前指针
        ListNode cur = head;
        //pre指向翻转链表后cur的next元素
        ListNode pre = null;
        //temp为临时指针
        ListNode temp = head;
        
        while (cur != null) {
            //保存下一个节点
            temp = cur.next;
            //反转
            cur.next = pre;
            //cur和pre都沿着原链表移动
            pre = cur;
            cur = temp;
        }
        
        return pre;
    }
}
```

递归：

```java
/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode() {}
 *     ListNode(int val) { this.val = val; }
 *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }
 * }
 */
class Solution {
    public ListNode reverseList(ListNode head) {
        //cur = head, pre = null
        return reverse(head, null);
    }
    private ListNode reverse(ListNode cur, ListNode pre){
        //如果当前元素为空，则递归结束，返回pre
        if(cur == null){
            return pre;
        }
        //反转过程
        ListNode temp;
        temp = cur.next;
        cur.next = pre;
        //更新pre和cur位置
        pre = cur;
        cur = temp;
        //继续调用
        return reverse(cur, pre);
    }
}
```

从后向前递归：

```java
// 从后向前递归
class Solution {
    ListNode reverseList(ListNode head) {
        // 边缘条件判断
        if(head == null) return null;
        if (head.next == null) return head;
        
        // 递归调用，翻转第二个节点开始往后的链表
        ListNode last = reverseList(head.next);
        // 翻转头节点与第二个节点的指向
        //最后一层返回head = 5，倒数第二层last = 5, head = 4
        //此处head.next.next->4.next.next->5.next->5.next=4
        head.next.next = head;
        // 此时的 head 节点为尾节点，next 需要从指向5变为指向 NULL
        head.next = null;
        return last;
    } 
}
```



### 24.两两交换链表中的节点

#### 题目

[24. 两两交换链表中的节点 - 力扣（LeetCode）](https://leetcode.cn/problems/swap-nodes-in-pairs/description/)

给你一个链表，两两交换其中相邻的节点，并返回交换后链表的头节点。你必须在不修改节点内部的值的情况下完成本题（即，只能进行节点交换）。

示例1：

![img](https://assets.leetcode.com/uploads/2020/10/03/swap_ex1.jpg)

```
输入：head = [1,2,3,4]
输出：[2,1,4,3]
```

示例2：

```
输入：head = []
输出：[]
```

示例3：

```
输入：head = [1]
输出：[1]
```



#### 思路

[视频讲解：24. 两两交换链表中的节点](https://www.bilibili.com/video/BV1YT411g7br/?spm_id_from=333.788&vd_source=ac7136f9d876267a31549d6a76ffd460)

按照题意正常模拟过程（使用虚拟头节点）：

![24.两两交换链表中的节点1](https://code-thinking.cdn.bcebos.com/pics/24.%E4%B8%A4%E4%B8%A4%E4%BA%A4%E6%8D%A2%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%9A%84%E8%8A%82%E7%82%B91.png)

![24.两两交换链表中的节点2](https://code-thinking.cdn.bcebos.com/pics/24.%E4%B8%A4%E4%B8%A4%E4%BA%A4%E6%8D%A2%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%9A%84%E8%8A%82%E7%82%B92.png)



递归：

用 head 表示原始链表的头节点，新的链表的第二个节点

用 newHead 表示新的链表的头节点，原始链表的第二个节点

则原始链表中的其余节点的头节点是 newHead.next。令 head.next = swapPairs(newHead.next)，表示将其余节点进行两两交换，交换后的新的头节点为 head 的下一个节点。然后令 newHead.next = head，即完成了所有节点的交换。最后返回新的链表的头节点 newHead。

#### 题解

[代码随想录：两两交换链表中的节点](https://www.programmercarl.com/0024.两两交换链表中的节点.html#算法公开课)

迭代：

```java
/**
 * Definition for singly-linked list.
 * public class ListNode {
 * int val;
 * ListNode next;
 * ListNode() {}
 * ListNode(int val) { this.val = val; }
 * ListNode(int val, ListNode next) { this.val = val; this.next = next; }
 * }
 */
class Solution {
    public ListNode swapPairs(ListNode head) {
        //虚拟头节点
        ListNode dummy = new ListNode(0);
        ListNode cur = dummy;
        dummy.next = head;
        while (cur.next != null && cur.next.next != null) {
            ListNode tmp1 = cur.next;
            ListNode tmp2 = cur.next.next.next;

            cur.next = cur.next.next;
            cur.next.next = tmp1;
            tmp1.next = tmp2;

            cur = cur.next.next;
        }

        return dummy.next;
    }
}
```

递归：

```java
class Solution {
    public ListNode swapPairs(ListNode head) {
        //退出提交
        if (head == null || head.next == null) {
            return head;
        }
        //获取当前节点的下一个节点
        ListNode newHead = head.next;
        //进行递归
        head.next = swapPairs(newHead.next);
        //交换
        newHead.next = head;
        return newHead;
    }
}
```



### 19.删除链表的倒数第N个节点

#### 题目

[19. 删除链表的倒数第 N 个结点 - 力扣（LeetCode）](https://leetcode.cn/problems/remove-nth-node-from-end-of-list/description/)

给你一个链表，删除链表的倒数第 `n` 个结点，并且返回链表的头结点。

示例1：

![img](https://assets.leetcode.com/uploads/2020/10/03/remove_ex1.jpg)

```
输入：head = [1,2,3,4,5], n = 2
输出：[1,2,3,5]
```

示例2：

```
输入：head = [1], n = 1
输出：[]
```

示例3：

```
输入：head = [1,2], n = 1
输出：[1]
```

**进阶：你能尝试使用一趟扫描实现吗？**

提示：

- 链表中结点的数目为 `sz`
- `1 <= sz <= 30`
- `0 <= Node.val <= 100`
- `1 <= n <= sz`

#### 思路

[视频讲解：19.删除链表倒数第N个节点](https://www.bilibili.com/video/BV1vW4y1U7Gf/?spm_id_from=333.788&vd_source=ac7136f9d876267a31549d6a76ffd460)

第一眼思路：先遍历整个链表，获取链表长度length，再根据length和n将指针移动到要删除的元素前一个的位置，然后删除即可。



进阶思路：使用双指针，要删除倒数第n个节点，让fast移动n步，然后让fast和slow同时移动，直到fast指向链表末尾。然后删除相应节点即可。

定义快慢指针和虚拟头节点：

<img src="https://assets.leetcode-cn.com/solution-static/19/p3.png" alt="p3" style="zoom: 80%;" />



#### 题解

[代码随想录：删除链表的倒数第N个节点](https://www.programmercarl.com/0019.删除链表的倒数第N个节点.html#算法公开课)

独立题解：

```java
/**
 * Definition for singly-linked list.
 * public class ListNode {
 * int val;
 * ListNode next;
 * ListNode() {}
 * ListNode(int val) { this.val = val; }
 * ListNode(int val, ListNode next) { this.val = val; this.next = next; }
 * }
 */
class Solution {
    public ListNode removeNthFromEnd(ListNode head, int n) {
        int length = 1;
        ListNode cur = head;
        ListNode dummy = new ListNode(0);
        dummy.next = head;
        while (cur.next != null) {
            cur = cur.next;
            length++;
        }
        cur = dummy;
        for (int i = 0; i < length - n; i++) {
            cur = cur.next;
        }
        cur.next = cur.next.next;
        return dummy.next;
    }
}
```

双指针：

```java
/**
 * Definition for singly-linked list.
 * public class ListNode {
 * int val;
 * ListNode next;
 * ListNode() {}
 * ListNode(int val) { this.val = val; }
 * ListNode(int val, ListNode next) { this.val = val; this.next = next; }
 * }
 */
class Solution {
    public ListNode removeNthFromEnd(ListNode head, int n) {
        ListNode dummy = new ListNode(0);
        dummy.next = head;
        ListNode fast = dummy;
        ListNode slow = dummy;

        for (int i = 0; i < n; i++) {
            fast = fast.next;
        }
        while (fast.next != null) {
            fast = fast.next;
            slow = slow.next;
        }
        //判断
        if (slow.next != null) {
            slow.next = slow.next.next;
        }

        return dummy.next;
    }
}
```



### 141.环形链表Ⅱ

#### 题目

[142. 环形链表 II - 力扣（LeetCode）](https://leetcode.cn/problems/linked-list-cycle-ii/description/)

给定一个链表的头节点  `head` ，返回链表开始入环的第一个节点。 *如果链表无环，则返回 `null`。*

如果链表中有某个节点，可以通过连续跟踪 `next` 指针再次到达，则链表中存在环。 为了表示给定链表中的环，评测系统内部使用整数 `pos` 来表示链表尾连接到链表中的位置（**索引从 0 开始**）。如果 `pos` 是 `-1`，则在该链表中没有环。**注意：`pos` 不作为参数进行传递**，仅仅是为了标识链表的实际情况。

**不允许修改** 链表。

示例1：

![img](https://assets.leetcode.com/uploads/2018/12/07/circularlinkedlist.png)

```
输入：head = [3,2,0,-4], pos = 1
输出：返回索引为 1 的链表节点
解释：链表中有一个环，其尾部连接到第二个节点。
```

示例2：

![img](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/07/circularlinkedlist_test2.png)

```
输入：head = [1,2], pos = 0
输出：返回索引为 0 的链表节点
解释：链表中有一个环，其尾部连接到第一个节点。
```

示例3：

![img](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/07/circularlinkedlist_test3.png)

```
输入：head = [1], pos = -1
输出：返回 null
解释：链表中没有环。
```



#### 思路

[视频讲解：142.环形链表Ⅱ](https://www.bilibili.com/video/BV1if4y1d7ob/?spm_id_from=333.788&vd_source=ac7136f9d876267a31549d6a76ffd460)

主要目标 ：先判断是否有环，如果有环，如何找到这个环的入口。

判断是否有环：可以使用快慢指针法，分别定义 fast 和 slow 指针，从头节点出发，fast指针每次移动两个节点，slow指针每次移动一个节点，如果 fast 和 slow指针在途中相遇 ，说明这个链表有环。如下图：

![141.环形链表](https://code-thinking.cdn.bcebos.com/gifs/141.%E7%8E%AF%E5%BD%A2%E9%93%BE%E8%A1%A8.gif)

找环的入口：采用数学方法，假设从头结点到环形入口节点 的节点数为x。 环形入口节点到 fast指针与slow指针相遇节点 节点数为y。 从相遇节点 再到环形入口节点节点数为 z。 如图所示：

![img](https://code-thinking-1253855093.file.myqcloud.com/pics/20220925103433.png)

计算如下：

![Snipaste_2024-06-04_10-51-51.png](https://github.com/JingHongB/LeetCodeStudy/blob/master/pictures/Snipaste_2024-06-04_10-51-51.png?raw=true)

n大于1的情况就是 fast 指针在环形转n圈之后才遇到 slow 指针。

这种情况和n为1的时候效果是一样的，一样可以通过这个方法找到环形的入口节点，只不过index1 指针在环里多转了(n-1)圈，然后再遇到index2，相遇点依然是环形的入口节点。

结论：从头节点出发一个指针，从相遇节点 也出发一个指针，两个指针每次只走一个节点，它们的相遇点就是环的入口。

#### 题解

[代码随想录：环形链表Ⅱ](https://www.programmercarl.com/0142.环形链表II.html#算法公开课)

```java
/**
 * Definition for singly-linked list.
 * class ListNode {
 * int val;
 * ListNode next;
 * ListNode(int x) {
 * val = x;
 * next = null;
 * }
 * }
 */
public class Solution {
    public ListNode detectCycle(ListNode head) {
        ListNode fast = head;
        ListNode slow = head;
        //判断是否成环
        while (fast != null && fast.next != null) {
            //快慢指针分别前进
            fast = fast.next.next;
            slow = slow.next;
            //相遇说明有环，开始找环入口位置
            if (fast == slow) {
                ListNode index1 = fast;
                ListNode index2 = head;
                while (index1 != index2) {
                    index1 = index1.next;
                    index2 = index2.next;
                }
                return index1;
            }
        }
        return null;
    }
}
```



### 160.相交链表

#### 题目

[160. 相交链表 - 力扣（LeetCode）](https://leetcode.cn/problems/intersection-of-two-linked-lists/description/)

给你两个单链表的头节点 `headA` 和 `headB` ，请你找出并返回两个单链表相交的起始节点。如果两个链表没有交点，返回 `null` 。

图示两个链表在节点 `c1` 开始相交：

![img](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/14/160_statement.png)

题目数据 **保证** 整个链式结构中不存在环。

**注意**，函数返回结果后，链表必须 **保持其原始结构** 。

示例1：

![img](https://assets.leetcode.com/uploads/2021/03/05/160_example_1_1.png)

```
输入：intersectVal = 8, listA = [4,1,8,4,5], listB = [5,6,1,8,4,5], skipA = 2, skipB = 3
输出：Intersected at '8'
解释：相交节点的值为 8 （注意，如果两个链表相交则不能为 0）。
从各自的表头开始算起，链表 A 为 [4,1,8,4,5]，链表 B 为 [5,6,1,8,4,5]。
在 A 中，相交节点前有 2 个节点；在 B 中，相交节点前有 3 个节点。
— 请注意相交节点的值不为 1，因为在链表 A 和链表 B 之中值为 1 的节点 (A 中第二个节点和 B 中第三个节点) 是不同的节点。换句话说，它们在内存中指向两个不同的位置，而链表 A 和链表 B 中值为 8 的节点 (A 中第三个节点，B 中第四个节点) 在内存中指向相同的位置。
```

示例2：

![img](https://assets.leetcode.com/uploads/2021/03/05/160_example_2.png)

```
输入：intersectVal = 2, listA = [1,9,1,2,4], listB = [3,2,4], skipA = 3, skipB = 1
输出：Intersected at '2'
解释：相交节点的值为 2 （注意，如果两个链表相交则不能为 0）。
从各自的表头开始算起，链表 A 为 [1,9,1,2,4]，链表 B 为 [3,2,4]。
在 A 中，相交节点前有 3 个节点；在 B 中，相交节点前有 1 个节点。
```

示例3：

![img](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/14/160_example_3.png)

```
输入：intersectVal = 0, listA = [2,6,4], listB = [1,5], skipA = 3, skipB = 2
输出：null
解释：从各自的表头开始算起，链表 A 为 [2,6,4]，链表 B 为 [1,5]。
由于这两个链表不相交，所以 intersectVal 必须为 0，而 skipA 和 skipB 可以是任意值。
这两个链表不相交，因此返回 null 。
```

**提示：**

- `listA` 中节点数目为 `m`
- `listB` 中节点数目为 `n`
- `0 <= m, n <= 3 * 104`
- `1 <= Node.val <= 105`
- `0 <= skipA <= m`
- `0 <= skipB <= n`
- 如果 `listA` 和 `listB` 没有交点，`intersectVal` 为 `0`
- 如果 `listA` 和 `listB` 有交点，`intersectVal == listA[skipA + 1] == listB[skipB + 1]`



#### 思路

差值法：求出两个链表的长度，并求出两个链表长度的差值，然后让长链表的指针移动到和短链表末尾对齐的位置。

如图：

<img src="https://code-thinking.cdn.bcebos.com/pics/%E9%9D%A2%E8%AF%95%E9%A2%9802.07.%E9%93%BE%E8%A1%A8%E7%9B%B8%E4%BA%A4_1.png" alt="面试题02.07.链表相交_1" style="zoom: 67%;" />

<img src="https://code-thinking.cdn.bcebos.com/pics/%E9%9D%A2%E8%AF%95%E9%A2%9802.07.%E9%93%BE%E8%A1%A8%E7%9B%B8%E4%BA%A4_2.png" alt="面试题02.07.链表相交_2" style="zoom:67%;" />

此时就可以比较curA和curB是否相同，如果不相同，同时向后移动curA和curB，如果遇到curA == curB，则找到交点。



合并链表：让两个链表从**距离末尾同等距离**的位置开始遍历。这个位置只能是较短链表的头结点位置。
为此，必须消除两个链表的长度差。

指针 pA 指向 A 链表，指针 pB 指向 B 链表，依次往后遍历
如果 pA 到了末尾，则 pA = headB 继续遍历
如果 pB 到了末尾，则 pB = headA 继续遍历
长链表指针指向短链表head时，长度差就被消除了

![相交链表.png](https://pic.leetcode-cn.com/e86e947c8b87ac723b9c858cd3834f9a93bcc6c5e884e41117ab803d205ef662-%E7%9B%B8%E4%BA%A4%E9%93%BE%E8%A1%A8.png)



#### 题解

[代码随想录：相交链表](https://www.programmercarl.com/面试题02.07.链表相交.html#思路)

差值法：

```java
/**
 * Definition for singly-linked list.
 * public class ListNode {
 * int val;
 * ListNode next;
 * ListNode(int x) {
 * val = x;
 * next = null;
 * }
 * }
 */
public class Solution {
    public ListNode getIntersectionNode(ListNode headA, ListNode headB) {
        ListNode curA = headA;
        ListNode curB = headB;
        int lengthA = 0;
        int lengthB = 0;

        //遍历链表获取长度
        while (curA != null) {
            lengthA++;
            curA = curA.next;
        }
        while (curB != null) {
            lengthB++;
            curB = curB.next;
        }
        //指针复原
        curA = headA;
        curB = headB;
        //将curA指向更长的链表表头
        if (lengthA < lengthB) {
            //更换length和head
            int tmp = lengthA;
            lengthA = lengthB;
            lengthB = tmp;

            curA = headB;
            curB = headA;
        }
        //移动长链表的指针，移动距离为长度差
        for (int i = 0; i < lengthA - lengthB; i++) {
            curA = curA.next;
        }
        //两个指针同时移动
        while (curA != curB) {
            curA = curA.next;
            curB = curB.next;
        }
        //遇到相交点，返回指针
        if (curA == curB) {
            return curA;
        }
        return null;
    }
}
```

合并链表：

```java
/**
 * Definition for singly-linked list.
 * public class ListNode {
 * int val;
 * ListNode next;
 * ListNode(int x) {
 * val = x;
 * next = null;
 * }
 * }
 */
public class Solution {
    public ListNode getIntersectionNode(ListNode headA, ListNode headB) {
        ListNode A = headA, B = headB;
        while (A != B) {
            A = A != null ? A.next : headB;
            B = B != null ? B.next : headA;
        }
        return A;
    }
}
```



## 哈希表

### 哈希表理论基础

#### 哈希表

哈希表是根据关键码的值而直接进行访问的数据结构。

数组就是一张哈希表，哈希表中关键码就是数组的索引下标，然后通过下标直接访问数组中的元素，如下图所示：

![哈希表1](https://code-thinking-1253855093.file.myqcloud.com/pics/20210104234805168.png)

**哈希表一般用来快速判断一个元素是否出现集合里。**

#### 哈希函数

哈希函数通过特定编码方式，可以将其他数据格式转化为不同的数值，映射到哈希表上的索引数字。

<img src="https://code-thinking-1253855093.file.myqcloud.com/pics/2021010423484818.png" alt="哈希表2" style="zoom:67%;" />

如果hashCode得到的数值大于哈希表的大小，此时为了保证映射出来的索引数值都落在哈希表上，**对数值做一个取模的操作。**

#### 哈希碰撞

如图所示，小李和小王都映射到了索引下标 1 的位置，这一现象叫做**哈希碰撞**。

<img src="https://code-thinking-1253855093.file.myqcloud.com/pics/2021010423494884.png" alt="哈希表3" style="zoom:67%;" />

哈希碰撞有两种解决方法， 拉链法和线性探测法。

##### 拉链法

将发生冲突的元素都存储在链表中，这样就可以通过索引找到冲突元素。

<img src="https://code-thinking-1253855093.file.myqcloud.com/pics/20210104235015226.png" alt="哈希表4" style="zoom:80%;" />

拉链法就是要选择适当的哈希表的大小，这样既不会因为数组空值而浪费大量内存，也不会因为链表太长而在查找上浪费太多时间。

##### 线性探测法

使用线性探测法，一定要保证tableSize大于dataSize，依靠哈希表中的空位来解决碰撞问题。

冲突的位置放了第一个元素，那么就向下找一个空位放置另一个元素的信息。所以要求tableSize一定要大于dataSize ，不然哈希表上没有空置的位置来存放冲突的数据了。如图所示：

<img src="https://code-thinking-1253855093.file.myqcloud.com/pics/20210104235109950.png" alt="哈希表5" style="zoom:80%;" />

#### 常见哈希结构

使用哈希法来解决问题的时候，一般选择如下三种数据结构：

- 数组
- set （集合）
- map（映射）



### 242.有效的字母异位词

#### 题目

[242. 有效的字母异位词 - 力扣（LeetCode）](https://leetcode.cn/problems/valid-anagram/description/)

给定两个字符串 `s` 和 `t` ，编写一个函数来判断 `t` 是否是 `s` 的字母异位词。

**注意：**若 `s` 和 `t` 中每个字符出现的次数都相同，则称 `s` 和 `t` 互为字母异位词。

示例1：

```
输入: s = "anagram", t = "nagaram"
输出: true
```

示例2：

```
输入: s = "rat", t = "car"
输出: false
```

**提示:**

- 1 <= s.length, t.length <= 5 * 10^4^
- `s` 和 `t` 仅包含小写字母

#### 思路

[视频讲解：242.有效的字母异位词](https://www.bilibili.com/video/BV1YG411p7BA/?spm_id_from=333.788&vd_source=ac7136f9d876267a31549d6a76ffd460)

**数组其实就是一个简单的哈希表**，本题中字符串只有小写字符，可以定义一个数组，来记录字符串s、t里字符出现的次数。

s中每出现一次某字母，相应位置++，t中每出现一次某字母，相应位置--：

![242.有效的字母异位词](https://code-thinking.cdn.bcebos.com/gifs/242.%E6%9C%89%E6%95%88%E7%9A%84%E5%AD%97%E6%AF%8D%E5%BC%82%E4%BD%8D%E8%AF%8D.gif)

遍历字符串的时候，通过字母和'a'的相对ASCII码获取相应下标。



#### 题解

[代码随想录：有效的字母异位词](https://www.programmercarl.com/0242.有效的字母异位词.html#算法公开课)

```java
class Solution {
    public boolean isAnagram(String s, String t) {
        int[] hash = new int[26];

        //使用.chatAt获取相应下标的字符
        for (int i = 0; i < s.length(); i++) {
            hash[s.charAt(i) - 'a']++;
        }
        for (int i = 0; i < t.length(); i++) {
            hash[t.charAt(i) - 'a']--;
        }
        for (int j = 0; j < 26; j++) {
            if (hash[j] != 0) {
                return false;
            }
        }
        return true;
    }
}
```



### 349.两个数组的交集

#### 题目

[349. 两个数组的交集 - 力扣（LeetCode）](https://leetcode.cn/problems/intersection-of-two-arrays/)

给定两个数组 `nums1` 和 `nums2` ，返回 *它们的 交集* 。输出结果中的每个元素一定是 **唯一** 的。我们可以 **不考虑输出结果的顺序** 。

示例1：

```
输入：nums1 = [1,2,2,1], nums2 = [2,2]
输出：[2]
```

示例2：

```
输入：nums1 = [4,9,5], nums2 = [9,4,9,8,4]
输出：[9,4]
解释：[4,9] 也是可通过的
```

**提示：**

- `1 <= nums1.length, nums2.length <= 1000`
- `0 <= nums1[i], nums2[i] <= 1000`



#### 思路

[视频讲解：349. 两个数组的交集](https://www.bilibili.com/video/BV1ba411S7wu/?spm_id_from=333.788&vd_source=ac7136f9d876267a31549d6a76ffd460)

[Java中的HashSet的常用方法总结-CSDN博客](https://blog.csdn.net/Liuxiaoyang1999/article/details/98878303?utm_medium=distribute.pc_relevant.none-task-blog-2~default~baidujs_baidulandingword~default-4-98878303-blog-123582721.235^v43^pc_blog_bottom_relevance_base4&spm=1001.2101.3001.4242.3&utm_relevant_index=7)

HashSet是没有重复元素且无序的集合。

由题要求输出去重且不考虑顺序，可使用HashSet：

<img src="https://code-thinking-1253855093.file.myqcloud.com/pics/20220707173513.png" alt="set哈希法" style="zoom:80%;" />



另外，题目给出提示：数组长度为1到1000，元素值为0到1000，所以可以使用数组作为哈希表。



#### 题解

[代码随想录：两个数组的交集](https://www.programmercarl.com/0202.快乐数.html#思路)

独立题解：

```java
class Solution {
    public int[] intersection(int[] nums1, int[] nums2) {
        //哈希数组
        int[] a = new int[1001];
        //存放结果
        List<Integer> list = new ArrayList<>();
        for (int i = 0; i < nums1.length; i++) {
            a[nums1[i]] = 1;
        }
        for (int j = 0; j < nums2.length; j++) {
            //去重
            if (a[nums2[j]] == 1 && list.contains(nums2[j]) == false) {
                list.add(nums2[j]);
            }
        }
        int[] ans = new int[list.size()];
        int index = 0;
        //for新语法
        for (int i : list) {
            ans[index++] = i;
        }
        return ans;
    }
}
```

Set：

```java
class Solution {
    public int[] intersection(int[] nums1, int[] nums2) {
        Set<Integer> set = new HashSet<>();
        Set<Integer> res = new HashSet<>();
        for (int i : nums1) {
            set.add(i);
        }
        for (int j : nums2) {
            if (set.contains(j)) {
                res.add(j);
            }
        }
        int index = 0;
        int[] ans = new int[res.size()];
        for (int k : res) {
            ans[index++] = k;
        }
        return ans;
    }
}
```



### 202.快乐数

#### 题目

[202. 快乐数 - 力扣（LeetCode）](https://leetcode.cn/problems/happy-number/description/)

编写一个算法来判断一个数 `n` 是不是快乐数。

**「快乐数」** 定义为：

- 对于一个正整数，每一次将该数替换为它每个位置上的数字的平方和。
- 然后重复这个过程直到这个数变为 1，也可能是 **无限循环** 但始终变不到 1。
- 如果这个过程 **结果为** 1，那么这个数就是快乐数。

如果 `n` 是 *快乐数* 就返回 `true` ；不是，则返回 `false` 。

示例1：

```
输入：n = 19
输出：true
解释：
1^2 + 9^2 = 82
8^2 + 2^2 = 68
6^2 + 8^2 = 100
1^2 + 0^2 + 0^2 = 1
```

示例2：

```
输入：n = 2
输出：false
```



#### 思路

由题，所有非快乐数计算后都会陷入死循环，即求得的sum一定会有重复值。

而快乐数的sum不会有重复值。

涉及出现次数，考虑用哈希表，又要求元素不能重复，考虑使用HashSet。



双指针法：由于所有非快乐数都会陷入死循环，所以该题可以类比 [142. 环形链表 II - 力扣（LeetCode）](https://leetcode.cn/problems/linked-list-cycle-ii/description/)

使用快慢指针，快指针每次移动一个距离，慢指针每次移动两个距离，如果两个指针相遇则说明不是快乐数。

<img src="https://assets.leetcode-cn.com/solution-static/202/1.jpg" alt="img" style="zoom:67%;" />

#### 题解

[代码随想录：快乐数](https://www.programmercarl.com/0202.快乐数.html#思路)

独立题解：

```java
class Solution {
    public boolean isHappy(int n) {
        int sum = 0;
        Set<Integer> set = new HashSet<>();
        while (true) {
            //求各位数平方和
            while (n != 0) {
                int num = n % 10;
                n /= 10;
                sum += num * num;
            }
            if (sum == 1)
                return true;
            if (set.contains(sum))
                return false;
            set.add(sum);
            n = sum;
            sum = 0;
        }
    }
}
```

快慢指针：

```java
class Solution {
    //获取下一个值的方法
     public int getNext(int n) {
        int totalSum = 0;
        while (n > 0) {
            int d = n % 10;
            n = n / 10;
            totalSum += d * d;
        }
        return totalSum;
    }
    
    public boolean isHappy(int n) {
        int slow = n;
        int fast = getNext(n);
        //循环直到 得到1/快慢指针相遇
        while (fast != 1 && slow != fast) {
            //慢指针移动一次
            slow = getNext(slow);
            //快指针移动两次
            fast = getNext(getNext(fast));
        }
        return fast == 1;
    }
}
```



### 1.两数之和

#### 题目

[1. 两数之和 - 力扣（LeetCode）](https://leetcode.cn/problems/two-sum/description/)

给定一个整数数组 `nums` 和一个整数目标值 `target`，请你在该数组中找出 **和为目标值** *`target`* 的那 **两个** 整数，并返回它们的数组下标。

你可以假设每种输入只会对应一个答案。但是，数组中同一个元素在答案里不能重复出现。

你可以按任意顺序返回答案。

示例1：

```
输入：nums = [2,7,11,15], target = 9
输出：[0,1]
解释：因为 nums[0] + nums[1] == 9 ，返回 [0, 1] 。
```

示例2：

```
输入：nums = [3,2,4], target = 6
输出：[1,2]
```

示例3：

```
输入：nums = [3,3], target = 6
输出：[0,1]
```

**提示：**

- `2 <= nums.length <= 104`
- `-109 <= nums[i] <= 109`
- `-109 <= target <= 109`
- **只会存在一个有效答案**



#### 思路

[视频讲解：1.两数之和](https://www.bilibili.com/video/BV1aT41177mK)

[Java HashMap | 菜鸟教程 (runoob.com)](https://www.runoob.com/java/java-hashmap.html)

初学时第一时间想到嵌套for循环暴力解法。

当需要查询**一个元素是否出现过**或者**一个元素是否在集合里**的时候，第一时间想到哈希法。

本题中不但需要存放遍历过的元素，还需要知道这个元素对应的下标，因此本题需要使用到key value结构，用key存放元素值，value存放元素下标，所以需要使用HashMap结构。

需要明确两点：

- map用来做什么
- map中key和value分别表示什么

map用来存放我们访问过的元素，因为遍历数组时，需要记录之前遍历过的元素和对应的下标，这样才能找到与当前元素之和等于target的元素。

因为返回值是下标，所以value存放数组元素下标，key存放元素值。

在遍历数组的时候，只需要在map中查询是否有和当前元素匹配的数值，如果有，就返回答案，如果没有，就把当前遍历的元素放进map中，因此map存放的是已经访问过的元素。

<img src="https://code-thinking-1253855093.file.myqcloud.com/pics/20220711202638.png" alt="过程一" style="zoom: 50%;" />

<img src="https://code-thinking-1253855093.file.myqcloud.com/pics/20230220223536.png" alt="过程二" style="zoom: 67%;" />

#### 题解

[代码随想录：两数之和](https://www.programmercarl.com/0001.两数之和.html)

```java
class Solution {
    public int[] twoSum(int[] nums, int target) {
        Map<Integer, Integer> map = new HashMap<>();
        int[] ans = new int[2];
        for (int i = 0; i < nums.length; i++) {
            int n = target - nums[i];
            if (map.containsKey(n)) {
                ans[0] = i;
                ans[1] = map.get(n);
                return ans;
            } else {
                map.put(nums[i], i);
            }
        }
        return ans;
    }
}
```



### 454.四数相加Ⅱ

#### 题目

[454. 四数相加 II - 力扣（LeetCode）](https://leetcode.cn/problems/4sum-ii/description/)

给你四个整数数组 `nums1`、`nums2`、`nums3` 和 `nums4` ，数组长度都是 `n` ，请你计算有多少个元组 `(i, j, k, l)` 能满足：

- `0 <= i, j, k, l < n`
- `nums1[i] + nums2[j] + nums3[k] + nums4[l] == 0`

示例1：

```
输入：nums1 = [1,2], nums2 = [-2,-1], nums3 = [-1,2], nums4 = [0,2]
输出：2
解释：
两个元组如下：
1. (0, 0, 0, 1) -> nums1[0] + nums2[0] + nums3[0] + nums4[1] = 1 + (-2) + (-1) + 2 = 0
2. (1, 1, 0, 0) -> nums1[1] + nums2[1] + nums3[0] + nums4[0] = 2 + (-1) + (-1) + 0 = 0
```

示例2：

```
输入：nums1 = [0], nums2 = [0], nums3 = [0], nums4 = [0]
输出：1
```



#### 思路

[视频讲解：454.四数相加II](https://www.bilibili.com/video/BV1Md4y1Q7Yh/?spm_id_from=333.788&vd_source=ac7136f9d876267a31549d6a76ffd460)

暴力解法为四层嵌套for循环，时间复杂度O(n^4^)

考虑使用哈希法：

1. 将所给数组分为两组
2. 用两层for循环求得数组1和数组2的元素之和，并存入HashMap，key为元素之和，value为出现次数
3. 再用两层for循环求得数组3和数组4的元素之和n，在哈希表中查找 key = -n 的value
4. count = value + count



#### 题解

[代码随想录：四数相加Ⅱ](https://www.programmercarl.com/0454.四数相加II.html#算法公开课)

```java
class Solution {
    public int fourSumCount(int[] nums1, int[] nums2, int[] nums3, int[] nums4) {
        Map<Integer, Integer> map = new HashMap<>();
        int l = nums1.length;
        int ans = 0;
        for (int i : nums1) {
            for (int j : nums2) {
                int sum = i + j;
                //修改已存在key的value
                //getOrDefault(key,defaultValue)
                //key为查找的键，defaultValue为不存在键时默认的value值
                map.put(sum, map.getOrDefault(sum, 0) + 1);
            }
        }
        for (int i : nums3) {
            for (int j : nums4) {
                int sum = i + j;
                ans += map.getOrDefault(0 - sum, 0);
            }
        }
        return ans;
    }
}
```



### 383.赎金信

#### 题目

[383. 赎金信 - 力扣（LeetCode）](https://leetcode.cn/problems/ransom-note/description/)

给你两个字符串：`ransomNote` 和 `magazine` ，判断 `ransomNote` 能不能由 `magazine` 里面的字符构成。

如果可以，返回 `true` ；否则返回 `false` 。

`magazine` 中的每个字符只能在 `ransomNote` 中使用一次。

示例1：

```
输入：ransomNote = "a", magazine = "b"
输出：false
```

示例2：

```
输入：ransomNote = "aa", magazine = "ab"
输出：false
```

示例3：

```
输入：ransomNote = "aa", magazine = "aab"
输出：true
```

**提示：**

- `1 <= ransomNote.length, magazine.length <= 105`
- `ransomNote` 和 `magazine` 由小写英文字母组成



#### 思路

用长度为26的数组来记录两个字符串中字母的出现次数，然后验证出现次数是否符合题意。

因为字母数量少，所以本题可以直接使用数组当哈希表。



#### 题解

[代码随想录：赎金信](https://www.programmercarl.com/0383.赎金信.html#思路)

独立题解：

```java
class Solution {
    public boolean canConstruct(String ransomNote, String magazine) {
        char[] ran = new char[26];
        char[] mag = new char[26];
        for (char ch : ransomNote.toCharArray()) {
            ran[ch - 'a']++;
        }
        for (char ch : magazine.toCharArray()) {
            mag[ch - 'a']++;
        }
        for (int i = 0; i < ran.length; i++) {
            if (ran[i] > mag[i]) {
                return false;
            }
        }
        return true;
    }
}
```

